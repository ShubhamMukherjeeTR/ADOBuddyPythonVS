Directory structure:
└── microsoft-azure-devops-mcp/
    ├── README.md
    ├── CODE_OF_CONDUCT.md
    ├── CONTRIBUTING.md
    ├── eslint.config.mjs
    ├── jest.config.cjs
    ├── LICENSE.md
    ├── mcp.json
    ├── package.json
    ├── SECURITY.md
    ├── SUPPORT.md
    ├── tsconfig.json
    ├── docs/
    │   ├── FAQ.md
    │   ├── HOWTO.md
    │   └── TROUBLESHOOTING.md
    ├── src/
    │   ├── index.ts
    │   ├── prompts.ts
    │   ├── tools.ts
    │   ├── utils.ts
    │   ├── version.ts
    │   └── tools/
    │       ├── auth.ts
    │       ├── builds.ts
    │       ├── core.ts
    │       ├── releases.ts
    │       ├── repos.ts
    │       ├── search.ts
    │       ├── testplans.ts
    │       ├── wiki.ts
    │       ├── work.ts
    │       └── workitems.ts
    ├── test/
    │   ├── mocks/
    │   │   └── work-items.ts
    │   └── src/
    │       └── tools/
    │           ├── core.test.ts
    │           ├── testplan.test.ts
    │           ├── wiki.test.ts
    │           ├── work.test.ts
    │           └── workitems.test.ts
    ├── .azuredevops/
    │   └── pipelines/
    │       └── release.yml
    ├── .devcontainer/
    │   └── devcontainer.json
    └── .github/
        ├── CODEOWNERS
        ├── copilot-instructions.md
        ├── dependabot.yml
        ├── PULL_REQUEST_TEMPLATE.md
        ├── acl/
        │   └── access.yml
        ├── ISSUE_TEMPLATE/
        │   ├── JitAccess.yml
        │   └── NewTool.md
        └── workflows/
            ├── build.yml
            ├── codeql.yml
            ├── dependency-review.yml
            └── version-update.yml

================================================
FILE: README.md
================================================
# ⭐ Azure DevOps MCP Server

Easily install the Azure DevOps MCP Server for VS Code or VS Code Insiders:

[![Install with NPX in VS Code](https://img.shields.io/badge/VS_Code-Install_AzureDevops_MCP_Server-0098FF?style=flat-square&logo=visualstudiocode&logoColor=white)](https://insiders.vscode.dev/redirect/mcp/install?name=ado&config=%7B%20%22type%22%3A%20%22stdio%22%2C%20%22command%22%3A%20%22npx%22%2C%20%22args%22%3A%20%5B%22-y%22%2C%20%22%40azure-devops%2Fmcp%22%2C%20%22%24%7Binput%3Aado_org%7D%22%5D%7D&inputs=%5B%7B%22id%22%3A%20%22ado_org%22%2C%20%22type%22%3A%20%22promptString%22%2C%20%22description%22%3A%20%22Azure%20DevOps%20organization%20name%20%20%28e.g.%20%27contoso%27%29%22%7D%5D)
[![Install with NPX in VS Code Insiders](https://img.shields.io/badge/VS_Code_Insiders-Install_AzureDevops_MCP_Server-24bfa5?style=flat-square&logo=visualstudiocode&logoColor=white)](https://insiders.vscode.dev/redirect/mcp/install?name=ado&quality=insiders&config=%7B%20%22type%22%3A%20%22stdio%22%2C%20%22command%22%3A%20%22npx%22%2C%20%22args%22%3A%20%5B%22-y%22%2C%20%22%40azure-devops%2Fmcp%22%2C%20%22%24%7Binput%3Aado_org%7D%22%5D%7D&inputs=%5B%7B%22id%22%3A%20%22ado_org%22%2C%20%22type%22%3A%20%22promptString%22%2C%20%22description%22%3A%20%22Azure%20DevOps%20organization%20name%20%20%28e.g.%20%27contoso%27%29%22%7D%5D)

This TypeScript project defines the **local** MCP server for Azure DevOps, enabling you to perform a wide range of Azure DevOps tasks directly from your code editor.

> 🚨 **Public Preview:** This project is in public preview. You can expect that the tools will change before general availability.

## 📄 Table of contents

1. [📺 Overview](#-overview)
2. [⚙️ Supported tools](#️-supported-tools)
3. [🔌 Installation & getting started](#-installation--getting-started)
4. [🔦 Usage](#-usage)
5. [📝 Troubleshooting](#-troubleshooting)
6. [🎩 Samples & best practices](#-samples--best-practices)
7. [🙋‍♀️ Frequently asked questions](#️-frequently-asked-questions)
8. [📌 Contributing](#️-contributing)

## 📺 Overview

The Azure DevOps MCP Server brings Azure DevOps context to your agents. Try prompts like:

- "List my ADO projects"
- "List ADO Builds for 'Contoso'"
- "List ADO Releases for 'Contoso'"
- "List ADO Repos for 'Contoso'"
- "List test plans for 'Contoso'"
- "List teams for project 'Contoso'"
- "List iterations for project 'Contoso'"
- "List my work items for project 'Contoso'"
- "List work items in current iteration for 'Contoso' project and 'Contoso Team'"

## ⚙️ Supported tools

Interact with these Azure DevOps services:

### 🧿 Core

- **core_list_project_teams**: Retrieve a list of teams for the specified Azure DevOps project.
- **core_list_projects**: Retrieve a list of projects in your Azure DevOps organization.

### ⚒️ Work

- **work_list_team_iterations**: Retrieve a list of iterations for a specific team in a project.
- **work_create_iterations**: Create new iterations in a specified Azure DevOps project.
- **work_assign_iterations**: Assign existing iterations to a specific team in a project.

### 📅 Work Items

- **wit_my_work_items**: Retrieve a list of work items relevent to the authenticated user.
- **wit_list_backlogs**: Revieve a list of backlogs for a given project and team.
- **wit_list_backlog_work_items**: Retrieve a list of backlogs of for a given project, team, and backlog category.
- **wit_get_work_item**: Get a single work item by ID.
- **wit_get_work_items_batch_by_ids**: Retrieve list of work items by IDs in batch.
- **wit_update_work_item**: Update a work item by ID with specified fields.
- **wit_create_work_item**: Create a new work item in a specified project and work item type.
- **wit_list_work_item_comments**: Retrieve list of comments for a work item by ID.
- **wit_get_work_items_for_iteration**: Retrieve a list of work items for a specified iteration.
- **wit_add_work_item_comment**: Add comment to a work item by ID.
- **wit_add_child_work_item**: Create a child work item from a parent by ID.
- **wit_link_work_item_to_pull_request**: Link a single work item to an existing pull request.
- **wit_get_work_item_type**: Get a specific work item type.
- **wit_get_query**: Get a query by its ID or path.
- **wit_get_query_results_by_id**: Retrieve the results of a work item query given the query ID.
- **wit_update_work_items_batch**: Update work items in batch.
- **wit_close_and_link_workitem_duplicates**: Close duplicate work items by id.
- **wit_work_items_link**: Link work items together in batch.

### 📁 Repositories

- **repo_list_repos_by_project**: Retrieve a list of repositories for a given project.
- **repo_list_pull_requests_by_repo**: Retrieve a list of pull requests for a given repository.
- **repo_list_pull_requests_by_project**: Retrieve a list of pull requests for a given project Id or Name.
- **repo_list_branches_by_repo**: Retrieve a list of branches for a given repository.
- **repo_list_my_branches_by_repo**: Retrieve a list of my branches for a given repository Id.
- **repo_list_pull_request_threads**: Retrieve a list of comment threads for a pull request.
- **repo_list_pull_request_thread_comments**: Retrieve a list of comments in a pull request thread.
- **repo_get_repo_by_name_or_id**: Get the repository by project and repository name or ID.
- **repo_get_branch_by_name**: Get a branch by its name.
- **repo_get_pull_request_by_id**: Get a pull request by its ID.
- **repo_create_pull_request**: Create a new pull request.
- **repo_update_pull_request_status**: Update status of an existing pull request to active or abandoned.
- **repo_reply_to_comment**: Replies to a specific comment on a pull request.
- **repo_resolve_comment**: Resolves a specific comment thread on a pull request.

### 🛰️ Builds

- **build_get_definitions**: Retrieves a list of build definitions for a given project.
- **build_get_definition_revisions**: Retrieves a list of revisions for a specific build definition.
- **build_get_builds**: Retrieves a list of builds for a given project.
- **build_get_log**: Retrieves the logs for a specific build.
- **build_get_log_by_id**: Get a specific build log by log ID.
- **build_get_changes**: Get the changes associated with a specific build.
- **build_run_build**: Triggers a new build for a specified definition.
- **build_get_status**: Fetches the status of a specific build.

### 🚀 Releases

- **release_get_definitions**: Retrieves list of release definitions for a given project.
- **release_get_releases**: Retrieves a list of releases for a given project.

### 🧪 Test Plans

- **testplan_create_test_plan**: Creates a new test plan in the project.
- **testplan_create_test_case**: Creates a new test case work item.
- **testplan_add_test_cases_to_suite**: Adds existing test cases to a test suite.
- **testplan_list_test_plans**: Retrieve a paginated list of test plans from an Azure DevOps project. Allows filtering for active plans and toggling detailed information.
- **testplan_list_test_cases**: Gets a list of test cases in the test plan.
- **testplan_show_test_results_from_build_id**: Gets a list of test results for a given project and build ID.

### 🔎 Search

- **search_code**: Get the code search results for a given search text.
- **search_wiki**: Get wiki search results for a given search text.
- **search_workitem**: Get work item search results for a given search text.

## 🔌 Installation & getting started

Clone the repository, install dependencies, and add it to your MCP client configuration.

### Visual Studio Code & GitHub Copilot

For the best experience, use Visual Studio Code and GitHub Copilot.

### Prerequisites

1. Install [VS Code](https://code.visualstudio.com/download) or [VS Code Insiders](https://code.visualstudio.com/insiders)
2. Install [Node.js](https://nodejs.org/en/download) 20+
3. Install [Azure CLI](https://learn.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest)
4. Open VS Code in an empty folder

### Azure Login

Ensure you are logged in to Azure DevOps via the Azure CLI:

```sh
az login
```

### Installation

#### ✨ One-Click install

[![Install with NPX in VS Code](https://img.shields.io/badge/VS_Code-Install_AzureDevops_MCP_Server-0098FF?style=flat-square&logo=visualstudiocode&logoColor=white)](https://insiders.vscode.dev/redirect/mcp/install?name=ado&config=%7B%20%22type%22%3A%20%22stdio%22%2C%20%22command%22%3A%20%22npx%22%2C%20%22args%22%3A%20%5B%22-y%22%2C%20%22%40azure-devops%2Fmcp%22%2C%20%22%24%7Binput%3Aado_org%7D%22%5D%7D&inputs=%5B%7B%22id%22%3A%20%22ado_org%22%2C%20%22type%22%3A%20%22promptString%22%2C%20%22description%22%3A%20%22Azure%20DevOps%20organization%20name%20%20%28e.g.%20%27contoso%27%29%22%7D%5D)
[![Install with NPX in VS Code Insiders](https://img.shields.io/badge/VS_Code_Insiders-Install_AzureDevops_MCP_Server-24bfa5?style=flat-square&logo=visualstudiocode&logoColor=white)](https://insiders.vscode.dev/redirect/mcp/install?name=ado&quality=insiders&config=%7B%20%22type%22%3A%20%22stdio%22%2C%20%22command%22%3A%20%22npx%22%2C%20%22args%22%3A%20%5B%22-y%22%2C%20%22%40azure-devops%2Fmcp%22%2C%20%22%24%7Binput%3Aado_org%7D%22%5D%7D&inputs=%5B%7B%22id%22%3A%20%22ado_org%22%2C%20%22type%22%3A%20%22promptString%22%2C%20%22description%22%3A%20%22Azure%20DevOps%20organization%20name%20%20%28e.g.%20%27contoso%27%29%22%7D%5D)

After installation, select GitHub Copilot Agent Mode and refresh the tools list. Learn more about Agent Mode in the [VS Code Documentation](https://code.visualstudio.com/docs/copilot/chat/chat-agent-mode).

#### 🧨 Installing from public feed (recommended)

This installation method is the easiest for all users using Visual Studio Code.

🎥 [Watch this quick start video to get up and running in under two minutes!](https://youtu.be/EUmFM6qXoYk)

##### Steps

1. In your project, add a `.vscode\mcp.json` file and add the following:

   ``` json
   {
      "inputs": [
        {
            "id": "ado_org",
            "type": "promptString",
            "description": "Azure DevOps organization name  (e.g. 'contoso')"
        }
      ],
      "servers": {
        "ado": {
            "type": "stdio",
            "command": "npx",
            "args": [
                "-y",
                "@azure-devops/mcp",
                "${input:ado_org}"
            ]
         }
      }
   }
   ```
2. Save the file and click 'Start`

   <img src="./docs/media/start-mcp-server.gif" alt="start mcp server" width="250"/>

3. In chat, switch to [Agent Mode](https://code.visualstudio.com/blogs/2025/02/24/introducing-copilot-agent-mode).
4. Click "Select Tools" and choose the available tools.
5. We strongly recommend that you create a `.github\copilot-instructions.md` in your project and copy and paste the contents from this [copilot-instructions.md](./.github/copilot-instructions.md) file. This will help your experience when it comes to using the Azure DevOps MCP Server in GitHub Copilot Chat.

#### 🛠️ Installing from source (dev mode)

This installation method is recommended for advanced users and contributors who want immediate access to the latest updates from the main branch. It is ideal if you are developing new tools, enhancing existing features, or maintaining a custom fork.

> **Note:** For most users, installing from the public feed is simpler and preferred. Use source installation only if you need the latest changes or are actively contributing to the project.

##### Steps

1. Clone the repository.
2. Install dependencies:
   ```sh
   npm install
   ```
3. Edit or add `.vscode/mcp.json`:

   ```json
   {
     "inputs": [
        {
           "id": "ado_org",
           "type": "promptString",
           "description": "Azure DevOps organization name  (e.g. 'contoso')"
        }
     ],
     "servers": {
        "ado": {
            "type": "stdio",
            "command": "mcp-server-azuredevops",
            "args": ["${input:ado_org}"]
        }
     }
   }
   ```

4. Start the Azure DevOps MCP Server

   <img src="./docs/media/start-mcp-server.gif" alt="start mcp server" width="250"/>
  
5. In chat, switch to [Agent Mode](https://code.visualstudio.com/blogs/2025/02/24/introducing-copilot-agent-mode).
6. Click "Select Tools" and choose the available tools.
7. We strongly recommend that you create a `.github\copilot-instructions.md` in your project and copy and paste the contents from this [copilot-instructions.md](./.github/copilot-instructions.md) file. This will help your experience when it comes to using the Azure DevOps MCP Server in GitHub Copilot Chat.

See [How To](./docs/HOWTO.md) section for details

## 🔦 Usage

### Visual Studio Code + GitHub Copilot

1. Open GitHub Copilot in VS Code and switch to Agent mode.
2. Start the Azure DevOps MCP Server.
3. The server appears in the tools list.
4. Try prompts like "List ADO projects".

### Visual Studio + GitHub Copilot

> *Prerequisites:* Visual Studio 2022 v17.14+, Agent mode enabled in Tools > Options > GitHub > Copilot > Copilot Chat.

1. Switch to Agent mode in the Copilot Chat window.
2. Enter your Azure DevOps organization name.
3. Select desired `ado` tools.
4. Try prompts like "List ADO projects".

For more details, see [Visual Studio MCP Servers documentation](https://learn.microsoft.com/en-us/visualstudio/ide/mcp-servers?view=vs-2022) and [Getting Started Video](https://www.youtube.com/watch?v=oPFecZHBCkg).

## 📝 Troubleshooting

See the [Troubleshooting guide](./docs/TROUBLESHOOTING.md) for help with common issues and logging.

## 🎩 Samples & best practices

Find sample prompts and best practices in our [How-to Guide](./docs/HOWTO.md).

## 🙋‍♀️ Frequently asked questions

For answers to common questions about the Azure DevOps MCP Server, see the [Frequently Asked Questions](./docs/FAQ.md).

## 📌 Contributing

We welcome contributions! During preview, please file Issues for bugs, enhancements, or documentation improvements.

See our [Contributions Guide](./CONTRIBUTING.md) for:

 - 🛠️ Development setup
 - ✨ Adding new tools
 - 📝 Code style & testing
 - 🔄 Pull request process

## 🤝 Code of conduct

This project follows the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/).
For questions, see the [FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or contact [open@microsoft.com](mailto:open@microsoft.com).

## License

Licensed under the [MIT License](./LICENSE.md).

---

_Trademarks: This project may include trademarks or logos for Microsoft or third parties. Use of Microsoft trademarks or logos must follow [Microsoft’s Trademark & Brand Guidelines](https://www.microsoft.com/en-us/legal/intellectualproperty/trademarks/usage/general). Third-party trademarks are subject to their respective policies._

<!-- version: 2023-04-07 [Do not delete this line, it is used for analytics that drive template improvements] -->



================================================
FILE: CODE_OF_CONDUCT.md
================================================
# Microsoft Open Source Code of Conduct

This project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/).

Resources:

- [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/)
- [Microsoft Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/)
- Contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with questions or concerns
- Employees can reach out at [aka.ms/opensource/moderation-support](https://aka.ms/opensource/moderation-support)



================================================
FILE: CONTRIBUTING.md
================================================
# Contributing to Azure DevOps MCP Server

Thank you for your interest in contributing to the Azure DevOps MCP Server! Your participation—whether through discussions, reporting issues, or suggesting improvements—helps us make the project better for everyone.

## 🪲 Bugs and feature requests

Before submitting a new issue or suggestion, please search the existing issues to check if it has already been reported. If you find a matching issue, upvote (👍) it and consider adding a comment describing your specific scenario or requirements. This helps us prioritize based on community impact.

If your concern is not already tracked, feel free to [log a new issue](https://github.com/microsoft/azure-devops-mcp/issues). The code owners team will review your submission and may approve, request clarification, or reject it. Once approved, you can proceed with your contribution.

## 📝 Creating issues

When creating an issue:

- **DO** use a clear, descriptive title that identifies the problem or requested feature.
- **DO** provide a detailed description of the issue or feature request.
- **DO** include any relevant REST endpoints you wish to integrate with. Refer to the [public REST API documentation](https://learn.microsoft.com/en-us/rest/api/azure/devops).

For reference, see [this example of a well-formed issue](<repo>_issues/41).

## 👩‍💻 Writing code

We are **not currently accepting pull requests** during the public preview phase. If you notice something that should be changed or added, please create an issue and provide details.

## 🖊️ Coding style

Follow the established patterns and styles in the repository. If you have suggestions for improvements, please open a new issue for discussion.

## 📑 Documentation

Update relevant documentation (e.g., README, existing code comments) to reflect new or altered functionality. Well-documented changes enable reviewers and future contributors to quickly understand the rationale and intended use of your code.

## 🤝 Code of conduct

You can find our code of conduct at the [Code of Conduct](./CODE_OF_CONDUCT.md) as a guideline for expected behavior in also at the contributions here. Please take a moment to review it before contributing.


================================================
FILE: eslint.config.mjs
================================================
import pluginHeader from 'eslint-plugin-header';
import tseslint from 'typescript-eslint';
import eslintConfigPrettier from 'eslint-config-prettier';

pluginHeader.rules.header.meta.schema = false; // workaround for https://github.com/Stuk/eslint-plugin-header/issues/57

export default tseslint.config(
  // Global ignores
  {
    ignores: ["dist/**", "coverage/**", "src/version.ts"],
  },

  // Basic rule set
  tseslint.configs.recommended,
  tseslint.configs.strict,
  tseslint.configs.stylistic,

  // Copyright
  {
    files: ["src/**/*.ts"],
    ignores: ["src/index.ts"],
    plugins: {
      header: pluginHeader,
    },
    rules: {
      "header/header": [
        "error",
        "line",
        [
          " Copyright (c) Microsoft Corporation.",
          " Licensed under the MIT License."
        ],
        2,
      ],
    },
  },

  // Prettier integration (must be last)
  eslintConfigPrettier
);



================================================
FILE: jest.config.cjs
================================================
module.exports = {
  // Use ts-jest preset for TypeScript support
  preset: 'ts-jest',

  // Specify the test environment (node for backend projects)
  testEnvironment: 'node',

  // Root directory for test files
  roots: ['<rootDir>/test'],

  // Glob patterns for test files
  testMatch: ['**/?(*.)+(spec|test).[jt]s?(x)'],

  // Automatically clear mock calls and instances between every test
  clearMocks: true,

  // Collect code coverage information
  collectCoverage: true,

  // Output directory for coverage reports
  coverageDirectory: 'coverage',

  // Coverage report formats
  coverageReporters: ['text', 'lcov'],

  // Module file extensions for importing
  moduleFileExtensions: ['ts', 'js'],

  // Transform settings for ts-jest
  transform: {
    '^.+\\.(ts|tsx)$': 'ts-jest'
  },

  moduleNameMapper: {
    '^(.+)/version\\.js$': '$1/version.ts',
    '^(.+)/utils\\.js$': '$1/utils.ts'
  }
};


================================================
FILE: LICENSE.md
================================================
    MIT License

    Copyright (c) Microsoft Corporation.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE



================================================
FILE: mcp.json
================================================
{
    "inputs": [
        {
            "id": "ado_org",
            "type": "promptString",
            "description": "Azure DevOps organization name  (e.g. 'contoso')"
        }
    ],
    "servers": {
        "ado": {
            "type": "stdio",
            "command": "mcp-server-azuredevops",
            "args": [
                "${input:ado_org}"
            ]
        }
    }
}


================================================
FILE: package.json
================================================
{
  "name": "@azure-devops/mcp",
  "version": "1.0.0",
  "description": "MCP server for interacting with Azure DevOps",
  "license": "MIT",
  "author": "Microsoft Corporation",
  "homepage": "TBD",
  "bugs": "TBD",
  "type": "module",
  "bin": {
    "mcp-server-azuredevops": "dist/index.js"
  },
  "files": [
    "dist"
  ],
  "publishConfig": {
    "access": "public"
  },
  "scripts": {
    "preinstall": "npm config set registry https://registry.npmjs.org/",
    "prebuild": "node -p \"'export const packageVersion = ' + JSON.stringify(require('./package.json').version) + ';\\r'\" > src/version.ts",
    "build": "tsc && shx chmod +x dist/*.js",
    "prepare": "npm run build",
    "watch": "tsc --watch",
    "inspect": "npx @modelcontextprotocol/inspector node dist/index.js",
    "start": "node -r tsconfig-paths/register dist/index.js",
    "eslint": "eslint",
    "eslint-fix": "eslint --fix",
    "clean": "shx rm -rf dist",
    "test": "jest"
  },
  "dependencies": {
    "@azure/identity": "^4.10.0",
    "@modelcontextprotocol/sdk": "1.13.2",
    "azure-devops-extension-api": "^4.252.0",
    "azure-devops-extension-sdk": "^4.0.2",
    "azure-devops-node-api": "^15.1.0",
    "zod": "^3.25.63",
    "zod-to-json-schema": "^3.24.5"
  },
  "devDependencies": {
    "@modelcontextprotocol/inspector": "^0.14.0",
    "@types/jest": "^30.0.0",
    "@types/node": "^22",
    "eslint-config-prettier": "10.1.5",
    "eslint-plugin-header": "^3.1.1",
    "jest": "^30.0.2",
    "jest-extended": "^6.0.0",
    "shx": "^0.4.0",
    "ts-jest": "^29.4.0",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.8.3",
    "typescript-eslint": "^8.32.1"
  }
}



================================================
FILE: SECURITY.md
================================================
Thanks in helping make Azure DevOps more secure for everyone.

## Security

Microsoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include [Microsoft](https://github.com/Microsoft), [Azure](https://github.com/Azure), [DotNet](https://github.com/dotnet), [AspNet](https://github.com/aspnet) and [Xamarin](https://github.com/xamarin).

If you believe you have found a security vulnerability in any Microsoft-owned repository that meets [Microsoft's definition of a security vulnerability](https://aka.ms/security.md/definition), please report it to us as described below.

## Reporting Security Issues

**Please do not report security vulnerabilities through public GitHub issues.**

Instead, please report them to the Microsoft Security Response Center (MSRC) at [https://msrc.microsoft.com/create-report](https://aka.ms/security.md/msrc/create-report).

If you prefer to submit without logging in, send email to [secure@microsoft.com](mailto:secure@microsoft.com).  If possible, encrypt your message with our PGP key; please download it from the [Microsoft Security Response Center PGP Key page](https://aka.ms/security.md/msrc/pgp).

You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at [microsoft.com/msrc](https://www.microsoft.com/msrc).

Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue:

  * Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.)
  * Full paths of source file(s) related to the manifestation of the issue
  * The location of the affected source code (tag/branch/commit or direct URL)
  * Any special configuration required to reproduce the issue
  * Step-by-step instructions to reproduce the issue
  * Proof-of-concept or exploit code (if possible)
  * Impact of the issue, including how an attacker might exploit the issue

This information will help us triage your report more quickly.

If you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our [Microsoft Bug Bounty Program](https://aka.ms/security.md/msrc/bounty) page for more details about our active programs.

## Preferred Languages

We prefer all communications to be in English.

## Policy

Microsoft follows the principle of [Coordinated Vulnerability Disclosure](https://aka.ms/security.md/cvd).



================================================
FILE: SUPPORT.md
================================================
# Support

## Supporting material

 - [How to guide](./docs/HOWTO.md)
 - [Troubleshooting](./docs/TROUBLESHOOTING.md)

## Security Related
For any Security concerns or Issues, please refer to [SECURITY.md](./SECURITY.md) on properly raising them.

## How to file issues and get help

This project uses GitHub Issues to track bugs and feature requests. Please refer to those guidelines to fill them: [CONTRIBUTING.md](./CONTRIBUTING.md)

## Microsoft Support Policy

Support for the azure-devops-mcp is limited to the resources listed above.


================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src",
    "baseUrl": "src",
    "target": "ES2022",
    "module": "Node16",
    "moduleResolution": "Node16",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "paths": {
      "@modules/*": [
        "modules/*"
      ],
      "@tools/*": [
        "tools/*"
      ],
      "@config/*": [
        "config/*"
      ],
      "@utils": [
        "utils.js"
     ]
    }
  },
  "include": [
    "./src/**/*",
    "./docs/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist"
  ]
}


================================================
FILE: docs/FAQ.md
================================================
Before you get started, ensure you follow the steps in the `README.md` file. This will help you get up and running and connected to your Azure DevOps organization.

### Does the MCP Server support both Azure DevOps Services and on-premises deployments?

Currently, the MCP Server supports only Azure DevOps Services. Several required API endpoints are not yet available for on-premises deployments. Additionally, focusing on Azure DevOps Services during the public preview makes it easier to debug and deliver fixes.

### Can I connect to more than one organization at a time?

No, you can connect to only one organization at a time. However, you can switch organizations as needed.

### Can I set a default project instead of fetching the list every time?

Currently, you need to fetch the list of projects so the LLM has context about the project name or ID. We plan to improve this experience in the future by leveraging prompts. In the meantime, you can set a default project name in your `copilot-instructions.md` file.



================================================
FILE: docs/HOWTO.md
================================================
Before you get started, ensure you follow the steps in the `README.md` file. This will help you get up and running and connected to your Azure DevOps organization.

## ✏️ Modify Copilot Instructions

The `.github/copilot-instructions.md` file is a great way to customize the GitHub Copilot experience, especially when working with MCP Server for Azure DevOps.

From the [GitHub documentation](https://docs.github.com/en/copilot/customizing-copilot/adding-repository-custom-instructions-for-github-copilot):

> Instead of repeatedly adding this contextual detail to your chat questions, you can create a file in your repository that automatically adds this information for you. The additional information is not displayed in the chat but is available to Copilot to allow it to generate higher-quality responses.

#### Example Modification

Here is an example modification you can add to your existing `.github/copilot-instructions.md` file.

```markdown
## Using MCP Server for Azure DevOps

When getting work items using MCP Server for Azure DevOps, always try to use batch tools for updates instead of many individual single updates. For updates, try and update up to 200 updates in a single batch. When getting work items, once you get the list of IDs, use the tool `get_work_items_batch_by_ids` to get the work item details. By default, show fields ID, Type, Title, State. Show work item results in a rendered markdown table.
```

## Sequential Thinking

The [Sequential Thinking](https://mcp.so/server/sequentialthinking) component helps break down complex problems into manageable steps, enabling the LLM to better understand your goals. If you encounter issues with the LLM's responses, consider adding the Sequential Thinking MCP Server to your `.vscode/mcp.json` file:

```json
{
  "inputs": [
    {
      "id": "ado_org",
      "type": "promptString",
      "description": "Azure DevOps organization name  (e.g. 'contoso')"
    }
  ],   
  "servers": {
    "ado": {
      "type": "stdio",
      "command": "mcp-server-azuredevops",
      "args": ["${input:ado_org}"]
    },
    "sequential-thinking": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-sequential-thinking"]
    }
  }
}
```

## 🎯 Different Models

Communicating with the LLM is both an art and a science. If the model does not respond well, switching to a different model may improve your results.

## 🚗 Using MCP Server in Visual Studio Code

### Start the Azure DevOps MCP Server:

To start the Azure DevOps MCP Server, open the `.vscode\mcp.json` file and click 'Start'

<img src="./media/start-mcp-server.gif" alt="start mcp server" width="250"/>

Enter your Azure DevOps organization name (e.g. `contoso`).

In chat, switch to [Agent Mode](https://code.visualstudio.com/blogs/2025/02/24/introducing-copilot-agent-mode).

### Enable or disable tools

Click "Select Tools" and choose the available tools.

<img src="./media/configure-mcp-server-tools.gif" alt="configure mcp server tools" width="300"/>

## 📽️ Examples

> 📝 These examples have been tested and validated only in English. If you encounter issues when using a different language, please open an issue in the repository so we can investigate.

### Projects and teams

Most work item tools require project context. You can retrieve the list of projects and specify the desired project:

```plaintext
get list of ado projects
```

This command returns all Azure DevOps projects for the organization defined in the `mcp.json` file. Similarly, you can retrieve the team context:

```plaintext
get list of teams for project contoso
```

📽️ [Azure DevOps MCP Server: Get list of projects and teams](https://youtu.be/x579E4_jNtY)


### Get my work items

Retrieve a list of work items assigned to you. This tool requires project context:

```plaintext
get my work items for project contoso
```

The model should automatically use the `wit_get_work_items_batch_by_ids` tool to fetch work item details.

📽️ [Azure DevOps MCP Server: Get my work items](https://youtu.be/y_ri8n7mBlg)

### Get all work items in a backlog

You need project, team and backlog (Epics, Stories, Features) context in order to get a list of all the work items in a backlog.

```plaintext
get backlogs for Contoso project and Fabrikam Team
```

Once you have the backlog levels, you can then get work items for that backlog.

```plaintext
get list of work items for Features backlog
```

The model should automatically use the `wit_get_work_items_batch_by_ids` tool to fetch work item details.

📽️ [Azure DevOps MCP Server: Get backlog](https://youtu.be/LouuyoscNrI)

### Retrieve and edit work items

Get a work item, get the work item comments, update the work item fields, and add a new comment.

```plaintext
Get work item 12345 and show me fields ID, Type, State, Repro Steps, Story Points, and Priority. Get all comments for the work item and summarize them for me.
```

The model now has context of the work item. You can then update specific fields. In this case, we want the LLM to generate a better set of Repro Steps and then update the work item with those new steps. Along with updating the Story Points and State fields.

```plaintext
Polish the Repro Steps with more information and details. Then take that value and update the work item. Also update StoryPoints = 5 and State = Active.
```

Assign the work item to me and add a new comment.

```plaintext
Assign this work item to myemail@outlook.com and add a comment "I will own this Bug and get it fixed"
```

📽️ [Azure DevOps MCP Server: Work with Work Items](https://youtu.be/tT7wqSIPKdA)

### Create and Link Test Cases

Open a user story and automatically generate test cases with detailed steps based on the story's description. Link the generated test cases back to the original user story.

```plaintext
Open work item 1234 in 'Contoso' project. Then look at the description and create 1-3 Test Cases with test steps. But show me a preview first before creating the Test Case in Azure DevOps. Be sure to link the new Test Case to the User Story 1234 when you do.
```

📽️ [Azure DevOps MCP Server: Creating Test Cases from Work Item](https://youtu.be/G7fnYjlSh_w)


================================================
FILE: docs/TROUBLESHOOTING.md
================================================
# Troubleshooting

## Common MCP Issues

1. **Clearing VS Code Cache**
   If you encounter issues with stale configurations, reload the VS Code window:
   - Press `Ctrl+Shift+P` (or `Cmd+Shift+P` on macOS).
   - Select `Developer: Reload Window`.

   You can also be more aggresive by clearing out the following folders:

   - `%APPDATA%\Code\Cache`
   - `%APPDATA%\Code\CachedData`
   - `%APPDATA%\Code\User\workspaceStorage`
   - `%APPDATA%\Code\logs`

   Clear Node Modules Cache

   - `npm cache clean --force`

2. **Server Not Showing Up in Agent Mode**
   Ensure that the `mcp.json` file is correctly configured and includes the appropriate server definitions. Restart your MCP server and reload the VS Code window.

3. **Tools Not Loading in Agent Mode**
   If tools are not appearing, click "Add Context" in Agent Mode and ensure all tools starting with `ado_` are selected.

4. **Too Many Tools Selected (Over 128 Limit)**
   VS Code supports a maximum of 128 tools. If you exceed this limit, ensure you do not have multiple MCP Servers running. Check both your project's `mcp.json` and your VS Code `settings.json` to confirm that the MCP Server is configured in only one location—not both.

## Project-Specific Issues
1. **npm Authentication Issues for Remote Access**
   If you encounter authentication errors while accessing the internal Codex-Deps feed (if using remote package):
   - Ensure you are logged in to Azure DevOps using the `az` CLI:
     ```pwsh
     az login
     ```
   - Verify your npm configuration:
     ```pwsh
     npm config get registry
     ```
     It should point to:
     - `https://pkgs.dev.azure.com/mseng/_packaging/Codex-Deps/npm/registry/` if remote.
     - `https://registry.npmjs.org/` if running it locally.

3. **Dependency Installation Errors**
   If `npm install` fails, ensure you are using Node.js version 20 or higher. You can check your Node.js version with:
   ```pwsh
   node -v
   ```

4. **Internal Feed Access**
   If you cannot access the internal Codex-Deps feed, confirm that you have the necessary permissions and that your Azure DevOps organization is correctly configured in `mcp.json`.



================================================
FILE: src/index.ts
================================================
#!/usr/bin/env node

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import * as azdev from "azure-devops-node-api";
import { AccessToken, DefaultAzureCredential } from "@azure/identity";
import { configurePrompts } from "./prompts.js";
import { configureAllTools } from "./tools.js";
import { userAgent } from "./utils.js";
import { packageVersion } from "./version.js";
const args = process.argv.slice(2);
if (args.length === 0) {  console.error(
    "Usage: mcp-server-azuredevops <organization_name>"
  );
  process.exit(1);
}

export const orgName = args[0];
const orgUrl = "https://dev.azure.com/" + orgName;

async function getAzureDevOpsToken(): Promise<AccessToken> {
  process.env.AZURE_TOKEN_CREDENTIALS = "dev";
  const credential = new DefaultAzureCredential(); // CodeQL [SM05138] resolved by explicitly setting AZURE_TOKEN_CREDENTIALS
  const token = await credential.getToken("499b84ac-1321-427f-aa17-267ca6975798/.default");
  return token;
}

async function getAzureDevOpsClient() : Promise<azdev.WebApi> {
  const token = await getAzureDevOpsToken();
  const authHandler = azdev.getBearerHandler(token.token);
  const connection = new azdev.WebApi(orgUrl, authHandler, undefined, {
    productName: "AzureDevOps.MCP",
    productVersion: packageVersion,
    userAgent: userAgent
  });
  return connection;
}

async function main() {
  const server = new McpServer({
    name: "Azure DevOps MCP Server",
    version: packageVersion,
  });

  configurePrompts(server);
  
  configureAllTools(
    server,
    getAzureDevOpsToken,
    getAzureDevOpsClient
  );

  const transport = new StdioServerTransport();
  console.log("Azure DevOps MCP Server version : " + packageVersion);
  await server.connect(transport);
}

main().catch((error) => {
  console.error("Fatal error in main():", error);
  process.exit(1);
});



================================================
FILE: src/prompts.ts
================================================
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

import {
  McpServer
} from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { CORE_TOOLS } from "./tools/core.js";
import { WORKITEM_TOOLS } from "./tools/workitems.js";

function configurePrompts(server: McpServer) {   

  server.prompt(
    "listProjects",
    "Lists all projects in the Azure DevOps organization.",
    {},
    () => ({
      messages: [
        {
          role: "user",
          content: {
            type: "text",
            text: String.raw`
# Task
Use the '${CORE_TOOLS.list_projects}' tool to retrieve all projects in the current Azure DevOps organization.
Present the results in a table with the following columns: Project ID, Name, and Description.`,
          },
        },
      ],
    })
  );

  server.prompt(
    "listTeams",
    "Retrieves all teams for a given Azure DevOps project.",
    { project: z.string() },
    ({ project }) => ({
      messages: [
        {
          role: "user",
          content: {
            type: "text",
            text: String.raw`
  # Task
  Use the '${CORE_TOOLS.list_project_teams}' tool to retrieve all teams for the project '${project}'.
  Present the results in a table with the following columns: Team ID, and Name`,
          },
        },
      ],
    })
  );

  server.prompt(
    "getWorkItem",
    "Retrieves details for a specific Azure DevOps work item by ID.",
    { id: z.string().describe("The ID of the work item to retrieve."),
      project: z.string().describe("The name or ID of the Azure DevOps project."),
    },
    ({ id, project }) => ({
      messages: [
        {
          role: "user",
          content: {
            type: "text",
            text: String.raw`
  # Task
  Use the '${WORKITEM_TOOLS.get_work_item}' tool to retrieve details for the work item with ID '${id}' in project '${project}'.
  Present the following fields: ID, Title, State, Assigned To, Work Item Type, Description or Repro Steps, and Created Date.`,
          },
        },
      ],
    })
  );

}

export { configurePrompts };



================================================
FILE: src/tools.ts
================================================
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { AccessToken } from "@azure/identity";
import { WebApi } from "azure-devops-node-api";

import { configureCoreTools } from "./tools/core.js";
import { configureWorkTools } from "./tools/work.js";
import { configureBuildTools } from "./tools/builds.js";
import { configureRepoTools } from "./tools/repos.js";
import { configureWorkItemTools } from "./tools/workitems.js";
import { configureReleaseTools } from "./tools/releases.js";
import { configureWikiTools } from "./tools/wiki.js";
import { configureTestPlanTools } from "./tools/testplans.js";
import { configureSearchTools } from "./tools/search.js";

function configureAllTools(
  server: McpServer,
  tokenProvider: () => Promise<AccessToken>,
  connectionProvider: () => Promise<WebApi>
) {
    configureCoreTools(server, tokenProvider, connectionProvider);
    configureWorkTools(server, tokenProvider, connectionProvider);
    configureBuildTools(server, tokenProvider, connectionProvider);
    configureRepoTools(server, tokenProvider, connectionProvider);
    configureWorkItemTools(server, tokenProvider, connectionProvider);
    configureReleaseTools(server, tokenProvider, connectionProvider);
    configureWikiTools(server, tokenProvider, connectionProvider);
    configureTestPlanTools(server, tokenProvider, connectionProvider);
    configureSearchTools(server, tokenProvider, connectionProvider);
}

export { configureAllTools };


================================================
FILE: src/utils.ts
================================================
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

import { packageVersion } from "./version.js";

export const apiVersion = "7.2-preview.1";
export const batchApiVersion = "5.0";
export const userAgent = `AzureDevOps.MCP/${packageVersion} (local)`



================================================
FILE: src/version.ts
================================================
export const packageVersion = "1.0.0";



================================================
FILE: src/tools/auth.ts
================================================
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

import { AccessToken } from "@azure/identity";
import { WebApi } from "azure-devops-node-api";

async function getCurrentUserDetails(tokenProvider: () => Promise<AccessToken>, connectionProvider: () => Promise<WebApi>) {
  const connection = await connectionProvider();
  const url = `${connection.serverUrl}/_apis/connectionData`;
  const token = (await tokenProvider()).token;
  const response = await fetch(url, {
    method: "GET",
    headers: {
      Authorization: `Bearer ${token}`,
      "Content-Type": "application/json",
    },
  });
  const data = await response.json();
  if (!response.ok) {
    throw new Error(`Error fetching user details: ${data.message}`);
  }
  return data;
}

export { getCurrentUserDetails };


================================================
FILE: src/tools/builds.ts
================================================
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

import { AccessToken } from "@azure/identity";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { WebApi } from "azure-devops-node-api";
import { BuildQueryOrder, DefinitionQueryOrder } from "azure-devops-node-api/interfaces/BuildInterfaces.js";
import { z } from "zod";

const BUILD_TOOLS = {
  get_definitions: "build_get_definitions",
  get_definition_revisions: "build_get_definition_revisions",
  get_builds: "build_get_builds",
  get_log: "build_get_log",
  get_log_by_id: "build_get_log_by_id",
  get_changes: "build_get_changes",
  run_build: "build_run_build",
  get_status: "build_get_status"
};

function configureBuildTools(
  server: McpServer,
  tokenProvider: () => Promise<AccessToken>,
  connectionProvider: () => Promise<WebApi>
) {
  
  server.tool(
    BUILD_TOOLS.get_definitions,
    "Retrieves a list of build definitions for a given project.",
    {
      project: z.string().describe("Project ID or name to get build definitions for"),
      repositoryId: z.string().optional().describe("Repository ID to filter build definitions"),
      repositoryType: z.enum(["TfsGit", "GitHub", "BitbucketCloud"]).optional().describe("Type of repository to filter build definitions"),
      name: z.string().optional().describe("Name of the build definition to filter"),
      path: z.string().optional().describe("Path of the build definition to filter"),
      queryOrder: z.nativeEnum(DefinitionQueryOrder).optional().describe("Order in which build definitions are returned"),
      top: z.number().optional().describe("Maximum number of build definitions to return"),
      continuationToken: z.string().optional().describe("Token for continuing paged results"),
      minMetricsTime: z.coerce.date().optional().describe("Minimum metrics time to filter build definitions"),
      definitionIds: z.array(z.number()).optional().describe("Array of build definition IDs to filter"),
      builtAfter: z.coerce.date().optional().describe("Return definitions that have builds after this date"),
      notBuiltAfter: z.coerce.date().optional().describe("Return definitions that do not have builds after this date"),
      includeAllProperties: z.boolean().optional().describe("Whether to include all properties in the results"),
      includeLatestBuilds: z.boolean().optional().describe("Whether to include the latest builds for each definition"),
      taskIdFilter: z.string().optional().describe("Task ID to filter build definitions"),
      processType: z.number().optional().describe("Process type to filter build definitions"),
      yamlFilename: z.string().optional().describe("YAML filename to filter build definitions"),
    },
    async ({
      project,
      repositoryId,
      repositoryType,
      name,
      path,
      queryOrder,
      top,
      continuationToken,
      minMetricsTime,
      definitionIds,
      builtAfter,
      notBuiltAfter,
      includeAllProperties,
      includeLatestBuilds,
      taskIdFilter,
      processType,
      yamlFilename,
    }) => {
      const connection = await connectionProvider();
      const buildApi = await connection.getBuildApi();
      const buildDefinitions = await buildApi.getDefinitions(
        project,
        name,
        repositoryId,
        repositoryType,
        queryOrder,
        top,
        continuationToken,
        minMetricsTime,
        definitionIds,
        path,
        builtAfter,
        notBuiltAfter,
        includeAllProperties,
        includeLatestBuilds,
        taskIdFilter,
        processType,
        yamlFilename
      );

      return {
        content: [{ type: "text", text: JSON.stringify(buildDefinitions, null, 2) }],
      };
    }
  );
  
  server.tool(
    BUILD_TOOLS.get_definition_revisions,
    "Retrieves a list of revisions for a specific build definition.",
    {
      project: z.string().describe("Project ID or name to get the build definition revisions for"),
      definitionId: z.number().describe("ID of the build definition to get revisions for"),
    },
    async ({ project, definitionId }) => {
      const connection = await connectionProvider();
      const buildApi = await connection.getBuildApi();
      const revisions = await buildApi.getDefinitionRevisions(project, definitionId);

      return {
        content: [{ type: "text", text: JSON.stringify(revisions, null, 2) }],
      };
    }
  );
 
  server.tool(
    BUILD_TOOLS.get_builds,
    "Retrieves a list of builds for a given project.",
    {
      project: z.string().describe("Project ID or name to get builds for"),
      definitions: z.array(z.number()).optional().describe("Array of build definition IDs to filter builds"),
      queues: z.array(z.number()).optional().describe("Array of queue IDs to filter builds"),
      buildNumber: z.string().optional().describe("Build number to filter builds"),
      minTime: z.coerce.date().optional().describe("Minimum finish time to filter builds"),
      maxTime: z.coerce.date().optional().describe("Maximum finish time to filter builds"),
      requestedFor: z.string().optional().describe("User ID or name who requested the build"),
      reasonFilter: z.number().optional().describe("Reason filter for the build (see BuildReason enum)"),
      statusFilter: z.number().optional().describe("Status filter for the build (see BuildStatus enum)"),
      resultFilter: z.number().optional().describe("Result filter for the build (see BuildResult enum)"),
      tagFilters: z.array(z.string()).optional().describe("Array of tags to filter builds"),
      properties: z.array(z.string()).optional().describe("Array of property names to include in the results"),
      top: z.number().optional().describe("Maximum number of builds to return"),
      continuationToken: z.string().optional().describe("Token for continuing paged results"),
      maxBuildsPerDefinition: z.number().optional().describe("Maximum number of builds per definition"),
      deletedFilter: z.number().optional().describe("Filter for deleted builds (see QueryDeletedOption enum)"),
      queryOrder: z.nativeEnum(BuildQueryOrder).default(BuildQueryOrder.QueueTimeDescending).optional().describe("Order in which builds are returned"),
      branchName: z.string().optional().describe("Branch name to filter builds"),
      buildIds: z.array(z.number()).optional().describe("Array of build IDs to retrieve"),
      repositoryId: z.string().optional().describe("Repository ID to filter builds"),
      repositoryType: z.enum(["TfsGit", "GitHub", "BitbucketCloud"]).optional().describe("Type of repository to filter builds"),
    },
    async ({
      project,
      definitions,
      queues,
      buildNumber,
      minTime,
      maxTime,
      requestedFor,
      reasonFilter,
      statusFilter,
      resultFilter,
      tagFilters,
      properties,
      top,
      continuationToken,
      maxBuildsPerDefinition,
      deletedFilter,
      queryOrder,
      branchName,
      buildIds,
      repositoryId,
      repositoryType,
    }) => {
      const connection = await connectionProvider();
      const buildApi = await connection.getBuildApi();
      const builds = await buildApi.getBuilds(
        project,
        definitions,
        queues,
        buildNumber,
        minTime,
        maxTime,
        requestedFor,
        reasonFilter,
        statusFilter,
        resultFilter,
        tagFilters,
        properties,
        top,
        continuationToken,
        maxBuildsPerDefinition,
        deletedFilter,
        queryOrder,
        branchName,
        buildIds,
        repositoryId,
        repositoryType
      );

      return {
        content: [{ type: "text", text: JSON.stringify(builds, null, 2) }],
      };
    }
  );
  
  server.tool(
    BUILD_TOOLS.get_log,
    "Retrieves the logs for a specific build.",
    {
      project: z.string().describe("Project ID or name to get the build log for"),
      buildId: z.number().describe("ID of the build to get the log for"),
    },
    async ({ project, buildId }) => {
      const connection = await connectionProvider();
      const buildApi = await connection.getBuildApi();
      const logs = await buildApi.getBuildLogs(project, buildId);

      return {
        content: [{ type: "text", text: JSON.stringify(logs, null, 2) }],
      };
    }
  );
  
  server.tool(
    BUILD_TOOLS.get_log_by_id,
    "Get a specific build log by log ID.",
    {
      project: z.string().describe("Project ID or name to get the build log for"),  
      buildId: z.number().describe("ID of the build to get the log for"),
      logId: z.number().describe("ID of the log to retrieve"),
      startLine: z.number().optional().describe("Starting line number for the log content, defaults to 0"),
      endLine: z.number().optional().describe("Ending line number for the log content, defaults to the end of the log"),
    },
    async ({ project, buildId, logId, startLine, endLine }) => {
      const connection = await connectionProvider();
      const buildApi = await connection.getBuildApi();
      const logLines = await buildApi.getBuildLogLines(
        project,
        buildId,
        logId,
        startLine,
        endLine
      );

      return {
        content: [{ type: "text", text: JSON.stringify(logLines, null, 2) }],
      };
    }
  );
  
  server.tool(
    BUILD_TOOLS.get_changes,
    "Get the changes associated with a specific build.",
    {
      project: z.string().describe("Project ID or name to get the build changes for"),
      buildId: z.number().describe("ID of the build to get changes for"),
      continuationToken: z.string().optional().describe("Continuation token for pagination"),
      top: z.number().default(100).describe("Number of changes to retrieve, defaults to 100"),
      includeSourceChange: z.boolean().optional().describe("Whether to include source changes in the results, defaults to false"),
    },
    async ({ project, buildId, continuationToken, top, includeSourceChange }) => {
      const connection = await connectionProvider();
      const buildApi = await connection.getBuildApi();
      const changes = await buildApi.getBuildChanges(
        project,
        buildId,
        continuationToken,
        top,
        includeSourceChange
      );

      return {
        content: [{ type: "text", text: JSON.stringify(changes, null, 2) }],
      };
    }
  );

  server.tool(
    BUILD_TOOLS.run_build,
    "Triggers a new build for a specified definition.",
    {
      project: z.string().describe("Project ID or name to run the build in"),
      definitionId: z.number().describe("ID of the build definition to run"),
      sourceBranch: z.string().optional().describe("Source branch to run the build from. If not provided, the default branch will be used."),
    },
    async ({ project, definitionId, sourceBranch }) => {
      const connection = await connectionProvider();
      const buildApi = await connection.getBuildApi();
      const build = await buildApi.queueBuild({ definition: { id: definitionId }, sourceBranch }, project);

      return {
        content: [{ type: "text", text: JSON.stringify(build, null, 2) }],
      };
    }
  );

  server.tool(
    BUILD_TOOLS.get_status,
    "Fetches the status of a specific build.",
    {
      project: z.string().describe("Project ID or name to get the build status for"),
      buildId: z.number().describe("ID of the build to get the status for"),
    },
    async ({ project, buildId }) => {
      const connection = await connectionProvider();
      const buildApi = await connection.getBuildApi();
      const build = await buildApi.getBuildReport(project, buildId);

      return {
        content: [{ type: "text", text: JSON.stringify(build, null, 2) }],
      };
    }
  );
}

export { BUILD_TOOLS, configureBuildTools };



================================================
FILE: src/tools/core.ts
================================================
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

import { AccessToken } from "@azure/identity";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { WebApi } from "azure-devops-node-api";
import { z } from "zod";

const CORE_TOOLS = {
  list_project_teams: "core_list_project_teams",
  list_projects: "core_list_projects",  
};

function configureCoreTools(
  server: McpServer,
  tokenProvider: () => Promise<AccessToken>,
  connectionProvider: () => Promise<WebApi>
) {
  
  server.tool(
    CORE_TOOLS.list_project_teams,
    "Retrieve a list of teams for the specified Azure DevOps project.",
    {
      project: z.string().describe("The name or ID of the Azure DevOps project."),
      mine: z.boolean().optional().describe("If true, only return teams that the authenticated user is a member of."),
      top: z.number().optional().describe("The maximum number of teams to return. Defaults to 100."),
      skip: z.number().optional().describe("The number of teams to skip for pagination. Defaults to 0."),     
    },
    async ({ project, mine, top, skip }) => {
      try {
        const connection = await connectionProvider();
        const coreApi = await connection.getCoreApi();
        const teams = await coreApi.getTeams(
          project,
          mine,
          top,
          skip,
          false
        );

        if (!teams) {
          return { content: [{ type: "text", text: "No teams found" }], isError: true };
        }

        return {
          content: [{ type: "text", text: JSON.stringify(teams, null, 2) }],
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        
        return { 
          content: [{ type: "text", text: `Error fetching project teams: ${errorMessage}` }], 
          isError: true
        };
      }
    }
  );
 
  server.tool(
    CORE_TOOLS.list_projects,
    "Retrieve a list of projects in your Azure DevOps organization.",
    {
      stateFilter: z.enum(["all", "wellFormed", "createPending", "deleted"]).default("wellFormed").describe("Filter projects by their state. Defaults to 'wellFormed'."),
      top: z.number().optional().describe("The maximum number of projects to return. Defaults to 100."),
      skip: z.number().optional().describe("The number of projects to skip for pagination. Defaults to 0."),
      continuationToken: z.number().optional().describe("Continuation token for pagination. Used to fetch the next set of results if available."),      
    },
    async ({ stateFilter, top, skip, continuationToken }) => {
      try {
        const connection = await connectionProvider();
        const coreApi = await connection.getCoreApi();
        const projects = await coreApi.getProjects(
          stateFilter,
          top,
          skip,
          continuationToken,
          false
        );

        if (!projects) {
          return { content: [{ type: "text", text: "No projects found" }], isError: true };
        }

        return {
          content: [{ type: "text", text: JSON.stringify(projects, null, 2) }],
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        
        return { 
          content: [{ type: "text", text: `Error fetching projects: ${errorMessage}` }], 
          isError: true
        };
      }
    }
  ); 
}

export { CORE_TOOLS, configureCoreTools };



================================================
FILE: src/tools/releases.ts
================================================
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

import { AccessToken } from "@azure/identity";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { WebApi } from "azure-devops-node-api";
import {
  ReleaseDefinitionExpands,
  ReleaseDefinitionQueryOrder,
  ReleaseExpands,
  ReleaseStatus,
  ReleaseQueryOrder,
} from "azure-devops-node-api/interfaces/ReleaseInterfaces.js";
import { z } from "zod";

const RELEASE_TOOLS = {
  get_release_definitions: "release_get_definitions",
  get_releases: "release_get_releases",
};

function configureReleaseTools(
  server: McpServer,
  tokenProvider: () => Promise<AccessToken>,
  connectionProvider: () => Promise<WebApi>
) {
  
  server.tool(
    RELEASE_TOOLS.get_release_definitions,
    "Retrieves list of release definitions for a given project.",
    {
      project: z.string().describe("Project ID or name to get release definitions for"),
      searchText: z.string().optional().describe("Search text to filter release definitions"),
      expand: z.nativeEnum(ReleaseDefinitionExpands).default(ReleaseDefinitionExpands.None).describe("Expand options for release definitions"),
      artifactType: z.string().optional().describe("Filter by artifact type"),
      artifactSourceId: z.string().optional().describe("Filter by artifact source ID"),
      top: z.number().optional().describe("Number of results to return (for pagination)"),
      continuationToken: z.string().optional().describe("Continuation token for pagination"),
      queryOrder: z.nativeEnum(ReleaseDefinitionQueryOrder).default(ReleaseDefinitionQueryOrder.NameAscending).describe("Order of the results"),
      path: z.string().optional().describe("Path to filter release definitions"),
      isExactNameMatch: z.boolean().optional().default(false).describe("Whether to match the exact name of the release definition. Default is false."),
      tagFilter: z.array(z.string()).optional().describe("Filter by tags associated with the release definitions"),
      propertyFilters: z.array(z.string()).optional().describe("Filter by properties associated with the release definitions"),
      definitionIdFilter: z.array(z.string()).optional().describe("Filter by specific release definition IDs"),
      isDeleted: z.boolean().default(false).describe("Whether to include deleted release definitions. Default is false."),
      searchTextContainsFolderName: z.boolean().optional().describe("Whether to include folder names in the search text"),
    },
    async ({
      project,
      searchText,
      expand,
      artifactType,
      artifactSourceId,
      top,
      continuationToken,
      queryOrder,
      path,
      isExactNameMatch,
      tagFilter,
      propertyFilters,
      definitionIdFilter,
      isDeleted,
      searchTextContainsFolderName,
    }) => {
      const connection = await connectionProvider();
      const releaseApi = await connection.getReleaseApi();
      const releaseDefinitions = await releaseApi.getReleaseDefinitions(
        project,
        searchText,
        expand,
        artifactType,
        artifactSourceId,
        top,
        continuationToken,
        queryOrder,
        path,
        isExactNameMatch,
        tagFilter,
        propertyFilters,
        definitionIdFilter,
        isDeleted,
        searchTextContainsFolderName
      );

      return {
        content: [
          { type: "text", text: JSON.stringify(releaseDefinitions, null, 2) },
        ],
      };
    }
  );
  
  server.tool(
    RELEASE_TOOLS.get_releases,
    "Retrieves a list of releases for a given project.",
    {
      project: z.string().optional().describe("Project ID or name to get releases for"),
      definitionId: z.number().optional().describe("ID of the release definition to filter releases"),
      definitionEnvironmentId: z.number().optional().describe("ID of the definition environment to filter releases"),
      searchText: z.string().optional().describe("Search text to filter releases"),
      createdBy: z.string().optional().describe("User ID or name who created the release"),
      statusFilter: z.nativeEnum(ReleaseStatus).optional().default(ReleaseStatus.Active).describe("Status of the releases to filter (default: Active)"),
      environmentStatusFilter: z.number().optional().describe("Environment status to filter releases"),
      minCreatedTime: z.coerce.date().optional().default(() => {
        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
        return sevenDaysAgo;
      }).describe("Minimum created time for releases (default: 7 days ago)"),
      maxCreatedTime: z.coerce.date().optional().default(() => new Date()).describe("Maximum created time for releases (default: now)"),
      queryOrder: z.nativeEnum(ReleaseQueryOrder).optional().default(ReleaseQueryOrder.Ascending).describe("Order in which to return releases (default: Ascending)"),
      top: z.number().optional().describe("Number of releases to return"),
      continuationToken: z.number().optional().describe("Continuation token for pagination"),
      expand: z.nativeEnum(ReleaseExpands).optional().default(ReleaseExpands.None).describe("Expand options for releases"),
      artifactTypeId: z.string().optional().describe("Filter releases by artifact type ID"),
      sourceId: z.string().optional().describe("Filter releases by artifact source ID"),
      artifactVersionId: z.string().optional().describe("Filter releases by artifact version ID"),
      sourceBranchFilter: z.string().optional().describe("Filter releases by source branch"),
      isDeleted: z.boolean().optional().default(false).describe("Whether to include deleted releases (default: false)"),
      tagFilter: z.array(z.string()).optional().describe("Filter releases by tags"),
      propertyFilters: z.array(z.string()).optional().describe("Filter releases by properties"),
      releaseIdFilter: z.array(z.number()).optional().describe("Filter by specific release IDs"),
      path: z.string().optional().describe("Path to filter releases"),
    },
    async ({
      project,
      definitionId,
      definitionEnvironmentId,
      searchText,
      createdBy,
      statusFilter,
      environmentStatusFilter,
      minCreatedTime,
      maxCreatedTime,
      queryOrder,
      top,
      continuationToken,
      expand,
      artifactTypeId,
      sourceId,
      artifactVersionId,
      sourceBranchFilter,
      isDeleted,
      tagFilter,
      propertyFilters,
      releaseIdFilter,
      path,
    }) => {
      const connection = await connectionProvider();
      const releaseApi = await connection.getReleaseApi();
      const releases = await releaseApi.getReleases(
        project,
        definitionId,
        definitionEnvironmentId,
        searchText,
        createdBy,
        statusFilter,
        environmentStatusFilter,
        minCreatedTime,
        maxCreatedTime,
        queryOrder,
        top,
        continuationToken,
        expand,
        artifactTypeId,
        sourceId,
        artifactVersionId,
        sourceBranchFilter,
        isDeleted,
        tagFilter,
        propertyFilters,
        releaseIdFilter,
        path
      );

      return {
        content: [{ type: "text", text: JSON.stringify(releases, null, 2) }],
      };
    }
  );
}

export { RELEASE_TOOLS, configureReleaseTools };



================================================
FILE: src/tools/repos.ts
================================================
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

import { AccessToken } from "@azure/identity";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { WebApi } from "azure-devops-node-api";
import { GitRef, PullRequestStatus } from "azure-devops-node-api/interfaces/GitInterfaces.js";
import { z } from "zod";
import { getCurrentUserDetails } from "./auth.js";

const REPO_TOOLS = {
  list_repos_by_project: "repo_list_repos_by_project",
  list_pull_requests_by_repo: "repo_list_pull_requests_by_repo",
  list_pull_requests_by_project: "repo_list_pull_requests_by_project",
  list_branches_by_repo: "repo_list_branches_by_repo",
  list_my_branches_by_repo: "repo_list_my_branches_by_repo",
  list_pull_request_threads: "repo_list_pull_request_threads",
  list_pull_request_thread_comments: "repo_list_pull_request_thread_comments",
  get_repo_by_name_or_id: "repo_get_repo_by_name_or_id",
  get_branch_by_name: "repo_get_branch_by_name",
  get_pull_request_by_id: "repo_get_pull_request_by_id",
  create_pull_request: "repo_create_pull_request",  
  update_pull_request_status: "repo_update_pull_request_status",
  reply_to_comment: "repo_reply_to_comment",
  resolve_comment: "repo_resolve_comment",
};

function branchesFilterOutIrrelevantProperties(
  branches: GitRef[],
  top: number
) {
  return branches
    ?.flatMap((branch) => (branch.name ? [branch.name] : []))
    ?.filter((branch) => branch.startsWith("refs/heads/"))
    .map((branch) => branch.replace("refs/heads/", ""))
    .slice(0, top);
}

function pullRequestStatusStringToInt(
  status: string)
: number {
  switch (status) {
    case "abandoned":
      return PullRequestStatus.Abandoned.valueOf();
    case "active":
      return PullRequestStatus.Active.valueOf();
    case "all":
      return PullRequestStatus.All.valueOf();
    case "completed":
      return PullRequestStatus.Completed.valueOf();
    case "notSet":
      return PullRequestStatus.NotSet.valueOf();
    default:
      throw new Error(`Unknown pull request status: ${status}`);
  }
}

function configureRepoTools(
  server: McpServer,
  tokenProvider: () => Promise<AccessToken>,
  connectionProvider: () => Promise<WebApi>
) {
  
  server.tool(
    REPO_TOOLS.create_pull_request,
    "Create a new pull request.",
    {
      repositoryId: z.string().describe("The ID of the repository where the pull request will be created."),
      sourceRefName: z.string().describe("The source branch name for the pull request, e.g., 'refs/heads/feature-branch'."),
      targetRefName: z.string().describe("The target branch name for the pull request, e.g., 'refs/heads/main'."),
      title: z.string().describe("The title of the pull request."),
      description: z.string().optional().describe("The description of the pull request. Optional."),
      isDraft: z.boolean().optional().default(false).describe("Indicates whether the pull request is a draft. Defaults to false."),
    },
    async ({
      repositoryId,
      sourceRefName,
      targetRefName,
      title,
      description,
      isDraft,
    }) => {
      const connection = await connectionProvider();
      const gitApi = await connection.getGitApi();
      const pullRequest = await gitApi.createPullRequest(
        {
          sourceRefName,
          targetRefName,
          title,
          description,
          isDraft,
        },
        repositoryId
      );

      return {
        content: [{ type: "text", text: JSON.stringify(pullRequest, null, 2) }],
      };
    }
  );

  server.tool(
    REPO_TOOLS.update_pull_request_status,
    "Update status of an existing pull request to active or abandoned.",
    {
      repositoryId: z.string().describe("The ID of the repository where the pull request exists."),
      pullRequestId: z.number().describe("The ID of the pull request to be published."),
      status: z.enum(["active", "abandoned"]).describe("The new status of the pull request. Can be 'active' or 'abandoned'."),
    },
    async ({ repositoryId, pullRequestId }) => {
      const connection = await connectionProvider();
      const gitApi = await connection.getGitApi();
      const statusValue = status === "active" ? 3 : 2;

      const updatedPullRequest = await gitApi.updatePullRequest(
        { status: statusValue },
        repositoryId,
        pullRequestId
      );

      return {
        content: [
          { type: "text", text: JSON.stringify(updatedPullRequest, null, 2) },
        ],
      };
    }
  ); 
 
  server.tool(
    REPO_TOOLS.list_repos_by_project,
    "Retrieve a list of repositories for a given project",
    { 
      project: z.string().describe("The name or ID of the Azure DevOps project."), 
    },
    async ({ project }) => {
      const connection = await connectionProvider();
      const gitApi = await connection.getGitApi();
      const repositories = await gitApi.getRepositories(
        project,
        false,
        false,
        false
      );

      // Filter out the irrelevant properties
      const filteredRepositories = repositories?.map((repo) => ({
        id: repo.id,
        name: repo.name,
        isDisabled: repo.isDisabled,
        isFork: repo.isFork,
        isInMaintenance: repo.isInMaintenance,
        webUrl: repo.webUrl,
        size: repo.size,
      }));

      return {
        content: [
          { type: "text", text: JSON.stringify(filteredRepositories, null, 2) },
        ],
      };
    }
  );
 
  server.tool(
    REPO_TOOLS.list_pull_requests_by_repo,
    "Retrieve a list of pull requests for a given repository.",
    {
      repositoryId: z.string().describe("The ID of the repository where the pull requests are located."),
      created_by_me: z.boolean().default(false).describe("Filter pull requests created by the current user."),
      i_am_reviewer: z.boolean().default(false).describe("Filter pull requests where the current user is a reviewer."),
      status: z.enum(["abandoned", "active", "all", "completed", "notSet"]).default("active").describe("Filter pull requests by status. Defaults to 'active'."),
    },
    async ({ repositoryId, created_by_me, i_am_reviewer, status }) => {
      const connection = await connectionProvider();
      const gitApi = await connection.getGitApi();

      // Build the search criteria
      const searchCriteria: {
        status: number;
        repositoryId: string;
        creatorId?: string;
        reviewerId?: string;
      } = {
        status: pullRequestStatusStringToInt(status),
        repositoryId: repositoryId,
      };

      if (created_by_me || i_am_reviewer) {
        const data = await getCurrentUserDetails(
          tokenProvider,
          connectionProvider
        );
        const userId = data.authenticatedUser.id;
        if (created_by_me) {
          searchCriteria.creatorId = userId;
        }
        if (i_am_reviewer) {
          searchCriteria.reviewerId = userId;
        }
      }

      const pullRequests = await gitApi.getPullRequests(
        repositoryId,
        searchCriteria
      );

      // Filter out the irrelevant properties
      const filteredPullRequests = pullRequests?.map((pr) => ({
        pullRequestId: pr.pullRequestId,
        codeReviewId: pr.codeReviewId,
        status: pr.status,
        createdBy: {
          displayName: pr.createdBy?.displayName,
          uniqueName: pr.createdBy?.uniqueName,
        },
        creationDate: pr.creationDate,
        title: pr.title,
        isDraft: pr.isDraft,
      }));

      return {
        content: [
          { type: "text", text: JSON.stringify(filteredPullRequests, null, 2) },
        ],
      };
    }
  );
 
  server.tool(
    REPO_TOOLS.list_pull_requests_by_project,
    "Retrieve a list of pull requests for a given project Id or Name.",
    {
      project: z.string().describe("The name or ID of the Azure DevOps project."),
      created_by_me: z.boolean().default(false).describe("Filter pull requests created by the current user."),
      i_am_reviewer: z.boolean().default(false).describe("Filter pull requests where the current user is a reviewer."),
      status: z.enum(["abandoned", "active", "all", "completed", "notSet"]).default("active").describe("Filter pull requests by status. Defaults to 'active'."),
    },
    async ({ project, created_by_me, i_am_reviewer, status }) => {
      const connection = await connectionProvider();
      const gitApi = await connection.getGitApi();

      // Build the search criteria
      const gitPullRequestSearchCriteria: {
        status: number;
        creatorId?: string;
        reviewerId?: string;
      } = {
        status: pullRequestStatusStringToInt(status),
      };

      if (created_by_me || i_am_reviewer) {
        const data = await getCurrentUserDetails(
          tokenProvider,
          connectionProvider
        );
        const userId = data.authenticatedUser.id;
        if (created_by_me) {
          gitPullRequestSearchCriteria.creatorId = userId;
        }
        if (i_am_reviewer) {
          gitPullRequestSearchCriteria.reviewerId = userId;
        }
      }

      const pullRequests = await gitApi.getPullRequestsByProject(
        project,
        gitPullRequestSearchCriteria
      );

      // Filter out the irrelevant properties
      const filteredPullRequests = pullRequests?.map((pr) => ({
        pullRequestId: pr.pullRequestId,
        codeReviewId: pr.codeReviewId,
        repository: pr.repository?.name,
        status: pr.status,
        createdBy: {
          displayName: pr.createdBy?.displayName,
          uniqueName: pr.createdBy?.uniqueName,
        },
        creationDate: pr.creationDate,
        title: pr.title,
        isDraft: pr.isDraft,
      }));

      return {
        content: [
          { type: "text", text: JSON.stringify(filteredPullRequests, null, 2) },
        ],
      };
    }
  );
  
  server.tool(
    REPO_TOOLS.list_pull_request_threads,
    "Retrieve a list of comment threads for a pull request.",
    {
      repositoryId: z.string().describe("The ID of the repository where the pull request is located."),
      pullRequestId: z.number().describe("The ID of the pull request for which to retrieve threads."),
      project: z.string().optional().describe("Project ID or project name (optional)"),
      iteration: z.number().optional().describe("The iteration ID for which to retrieve threads. Optional, defaults to the latest iteration."),
      baseIteration: z.number().optional().describe("The base iteration ID for which to retrieve threads. Optional, defaults to the latest base iteration."),
    },
    async ({
      repositoryId,
      pullRequestId,
      project,
      iteration,
      baseIteration,
    }) => {
      const connection = await connectionProvider();
      const gitApi = await connection.getGitApi();

      const threads = await gitApi.getThreads(
        repositoryId,
        pullRequestId,
        project,
        iteration,
        baseIteration
      );

      return {
        content: [{ type: "text", text: JSON.stringify(threads, null, 2) }],
      };
    }
  );
  
  server.tool(
    REPO_TOOLS.list_pull_request_thread_comments,
    "Retrieve a list of comments in a pull request thread.",
    {
      repositoryId: z.string().describe("The ID of the repository where the pull request is located."),
      pullRequestId: z.number().describe("The ID of the pull request for which to retrieve thread comments."),
      threadId: z.number().describe("The ID of the thread for which to retrieve comments."),
      project: z.string().optional().describe("Project ID or project name (optional)"),
    },
    async ({ repositoryId, pullRequestId, threadId, project }) => {
      const connection = await connectionProvider();
      const gitApi = await connection.getGitApi();

      // Get thread comments - GitApi uses getComments for retrieving comments from a specific thread
      const comments = await gitApi.getComments(
        repositoryId,
        pullRequestId,
        threadId,
        project
      );

      return {
        content: [{ type: "text", text: JSON.stringify(comments, null, 2) }],
      };
    }
  );
  
  server.tool(
    REPO_TOOLS.list_branches_by_repo,
    "Retrieve a list of branches for a given repository.",
    {
      repositoryId: z.string().describe("The ID of the repository where the branches are located."),
      top: z.number().default(100).describe("The maximum number of branches to return. Defaults to 100."),
    },
    async ({ repositoryId, top }) => {
      const connection = await connectionProvider();
      const gitApi = await connection.getGitApi();
      const branches = await gitApi.getRefs(repositoryId, undefined);

      const filteredBranches = branchesFilterOutIrrelevantProperties(
        branches,
        top
      );

      return {
        content: [
          { type: "text", text: JSON.stringify(filteredBranches, null, 2) },
        ],
      };
    }
  );

  server.tool(
    REPO_TOOLS.list_my_branches_by_repo,
    "Retrieve a list of my branches for a given repository Id.",
    {
      repositoryId: z.string().describe("The ID of the repository where the branches are located."),
    },
    async ({ repositoryId }) => {
      const connection = await connectionProvider();
      const gitApi = await connection.getGitApi();
      const branches = await gitApi.getRefs(
        repositoryId,
        undefined,
        undefined,
        undefined,
        undefined,
        true
      );

      return {
        content: [{ type: "text", text: JSON.stringify(branches, null, 2) }],
      };
    }
  );

  server.tool(
    REPO_TOOLS.get_repo_by_name_or_id,
    "Get the repository by project and repository name or ID.",
    {
      project: z.string().describe("Project name or ID where the repository is located."),
      repositoryNameOrId: z.string().describe("Repository name or ID."),
    },
    async ({ project, repositoryNameOrId }) => {
      const connection = await connectionProvider();
      const gitApi = await connection.getGitApi();
      const repositories = await gitApi.getRepositories(project);

      const repository = repositories?.find((repo) => repo.name === repositoryNameOrId || repo.id === repositoryNameOrId);
      
      if (!repository) {
        throw new Error(
          `Repository ${repositoryNameOrId} not found in project ${project}`
        );
      }

      return {
        content: [{ type: "text", text: JSON.stringify(repository, null, 2) }],
      };
    }
  );
 
  server.tool(
    REPO_TOOLS.get_branch_by_name,
    "Get a branch by its name.",
    { 
      repositoryId: z.string().describe("The ID of the repository where the branch is located."), 
      branchName: z.string().describe("The name of the branch to retrieve, e.g., 'main' or 'feature-branch'."), 
    },
    async ({ repositoryId, branchName }) => {
      const connection = await connectionProvider();
      const gitApi = await connection.getGitApi();
      const branches = await gitApi.getRefs(repositoryId);
      const branch = branches?.find(
        (branch) => branch.name === `refs/heads/${branchName}`
      );
      if (!branch) {
        return {
          content: [
            {
              type: "text",
              text: `Branch ${branchName} not found in repository ${repositoryId}`,
            },
          ],
        };
      }
      return {
        content: [{ type: "text", text: JSON.stringify(branch, null, 2) }],
      };
    }
  );
 
  server.tool(
    REPO_TOOLS.get_pull_request_by_id,
    "Get a pull request by its ID.",
    { 
      repositoryId: z.string().describe("The ID of the repository where the pull request is located."), 
      pullRequestId: z.number().describe("The ID of the pull request to retrieve."), 
    },
    async ({ repositoryId, pullRequestId }) => {
      const connection = await connectionProvider();
      const gitApi = await connection.getGitApi();
      const pullRequest = await gitApi.getPullRequest(
        repositoryId,
        pullRequestId
      );
      return {
        content: [{ type: "text", text: JSON.stringify(pullRequest, null, 2) }],
      };
    }
  );

  server.tool(
    REPO_TOOLS.reply_to_comment,
    "Replies to a specific comment on a pull request.",
    {
      repositoryId: z.string().describe("The ID of the repository where the pull request is located."),
      pullRequestId: z.number().describe("The ID of the pull request where the comment thread exists."),
      threadId: z.number().describe("The ID of the thread to which the comment will be added."),
      content: z.string().describe("The content of the comment to be added."),
      project: z.string().optional().describe("Project ID or project name (optional)"),
    },
    async ({ repositoryId, pullRequestId, threadId, content, project }) => {
      const connection = await connectionProvider();
      const gitApi = await connection.getGitApi();
      const comment = await gitApi.createComment(
        { content },
        repositoryId,
        pullRequestId,
        threadId,
        project
      );

      return {
        content: [{ type: "text", text: JSON.stringify(comment, null, 2) }],
      };
    }
  );
  
  server.tool(
    REPO_TOOLS.resolve_comment,
    "Resolves a specific comment thread on a pull request.",
    {
      repositoryId: z.string().describe("The ID of the repository where the pull request is located."),
      pullRequestId: z.number().describe("The ID of the pull request where the comment thread exists."),
      threadId: z.number().describe("The ID of the thread to be resolved."),
    },
    async ({ repositoryId, pullRequestId, threadId }) => {
      const connection = await connectionProvider();
      const gitApi = await connection.getGitApi();
      const thread = await gitApi.updateThread(
        { status: 2 }, // 2 corresponds to "Resolved" status
        repositoryId,
        pullRequestId,
        threadId
      );

      return {
        content: [{ type: "text", text: JSON.stringify(thread, null, 2) }],
      };
    }
  );
}

export { REPO_TOOLS, configureRepoTools };



================================================
FILE: src/tools/search.ts
================================================
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

import { AccessToken } from "@azure/identity";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { WebApi } from "azure-devops-node-api";
import { IGitApi } from "azure-devops-node-api/GitApi.js";
import { z } from "zod";
import { apiVersion , userAgent } from "../utils.js";
import { orgName } from "../index.js";
import { VersionControlRecursionType } from "azure-devops-node-api/interfaces/GitInterfaces.js";
import { GitItem } from "azure-devops-node-api/interfaces/GitInterfaces.js";

const SEARCH_TOOLS = {
  search_code: "search_code",
  search_wiki: "search_wiki",
  search_workitem: "search_workitem"
};

function configureSearchTools(
  server: McpServer,
  tokenProvider: () => Promise<AccessToken>,
  connectionProvider: () => Promise<WebApi>
) {
  /*
    CODE SEARCH
    Get the code search results for a given search text.
  */
server.tool(
  SEARCH_TOOLS.search_code,
  "Get the code search results for a given search text.",
  {
    searchRequest: z.object({
      searchText: z.string().describe("Search text to find in code"),
      $skip: z.number().default(0).describe("Number of results to skip (for pagination)"),
      $top: z.number().default(5).describe("Number of results to return (for pagination)"),
      filters: z.object({
        Project: z.array(z.string()).optional().describe("Filter in these projects"),
        Repository: z.array(z.string()).optional().describe("Filter in these repositories"),
        Path: z.array(z.string()).optional().describe("Filter in these paths"),
        Branch: z.array(z.string()).optional().describe("Filter in these branches"),
        CodeElement: z.array(z.string()).optional().describe("Filter for these code elements (e.g., classes, functions, symbols)"),
        // Note: CodeElement is optional and can be used to filter results by specific code elements.
        // It can be a string or an array of strings.
        // If provided, the search will only return results that match the specified code elements.
        // This is useful for narrowing down the search to specific classes, functions, definitions, or symbols.
        // Example: CodeElement: ["MyClass", "MyFunction"]
      }).partial().optional(),
      includeFacets: z.boolean().optional()
    }).strict()
  },
  async ({  searchRequest }) => {
    const accessToken = await tokenProvider();
    const connection = await connectionProvider();
    const url = `https://almsearch.dev.azure.com/${orgName}/_apis/search/codesearchresults?api-version=${apiVersion}`;

    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${accessToken.token}`,
        "User-Agent": `${userAgent}`
      },
      body: JSON.stringify(searchRequest),
    });

    if (!response.ok) {
      throw new Error(`Azure DevOps Code Search API error: ${response.status} ${response.statusText}`);
    }

    const resultText = await response.text();
    const resultJson = JSON.parse(resultText) as { results?: SearchResult[] };

    const topResults: SearchResult[] = Array.isArray(resultJson.results)
      ? resultJson.results.slice(0, Math.min(searchRequest.$top, resultJson.results.length))
      : [];

    const gitApi = await connection.getGitApi();
    const combinedResults = await fetchCombinedResults(topResults, gitApi);

    return {
      content: [
        { type: "text", text: resultText + JSON.stringify(combinedResults) }
      ]
    };
  }
);

/*
  WIKI SEARCH
  Get wiki search results for a given search text.
*/
server.tool(
  SEARCH_TOOLS.search_wiki,
  "Get wiki search results for a given search text.",
  {
    searchRequest: z.object({
      searchText: z.string().describe("Search text to find in wikis"),
      $skip: z.number().default(0).describe("Number of results to skip (for pagination)"),
      $top: z.number().default(10).describe("Number of results to return (for pagination)"),
      filters: z.object({
        Project: z.array(z.string()).optional().describe("Filter in these projects"),
        Wiki: z.array(z.string()).optional().describe("Filter in these wiki names"),
      }).partial().optional().describe("Filters to apply to the search text"),
      includeFacets: z.boolean().optional()
    }).strict()
  },
  async ({ searchRequest }) => {
    const accessToken = await tokenProvider();
    const url = `https://almsearch.dev.azure.com/${orgName}/_apis/search/wikisearchresults?api-version=${apiVersion}`;

    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${accessToken.token}`,
        "User-Agent": `${userAgent}`
      },
      body: JSON.stringify(searchRequest),
    });

    if (!response.ok) {
      throw new Error(`Azure DevOps Wiki Search API error: ${response.status} ${response.statusText}`);
    }

    const result = await response.text();
    return {
      content: [
        { type: "text", text: result }
      ]
    };
  }
);

/*
  WORK ITEM SEARCH
  Get work item search results for a given search text.
*/
server.tool(
  SEARCH_TOOLS.search_workitem,
  "Get work item search results for a given search text.",
  {
    searchRequest: z.object({
      searchText: z.string().describe("Search text to find in work items"),
      $skip: z.number().default(0).describe("Number of results to skip for pagination"),
      $top: z.number().default(10).describe("Number of results to return"),
      filters: z.object({
        "System.TeamProject": z.array(z.string()).optional().describe("Filter by team project"),
        "System.AreaPath": z.array(z.string()).optional().describe("Filter by area path"),
        "System.WorkItemType": z.array(z.string()).optional().describe("Filter by work item type like Bug, Task, User Story"),
        "System.State": z.array(z.string()).optional().describe("Filter by state"),
        "System.AssignedTo": z.array(z.string()).optional().describe("Filter by assigned to"),
      }).partial().optional(),
      includeFacets: z.boolean().optional()
    }).strict()
  },
  async ({ searchRequest }) => {
    const accessToken = await tokenProvider();
    const url = `https://almsearch.dev.azure.com/${orgName}/_apis/search/workitemsearchresults?api-version=${apiVersion}`;

    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${accessToken.token}`,
        "User-Agent": `${userAgent}`
      },
      body: JSON.stringify(searchRequest),
    });

    if (!response.ok) {
      throw new Error(`Azure DevOps Work Item Search API error: ${response.status} ${response.statusText}`);
    }

    const result = await response.text();
    return {
      content: [
        { type: "text", text: result }
      ]
    };
  }
);
}

/*
  Fetch git repo file content for top 5(default) search results.
*/

interface SearchResult {
  project?: { id?: string };
  repository?: { id?: string };
  path?: string;
  versions?: { changeId?: string }[];
  [key: string]: unknown;
}

type CombinedResult =
  | { gitItem: GitItem }
  | { error: string };

async function fetchCombinedResults(
  topSearchResults: SearchResult[],
  gitApi: IGitApi
): Promise<CombinedResult[]> {
  const combinedResults: CombinedResult[] = [];
  for (const searchResult of topSearchResults) {
    try {
      const projectId = searchResult.project?.id;
      const repositoryId = searchResult.repository?.id;
      const filePath = searchResult.path;
      const changeId = Array.isArray(searchResult.versions) && searchResult.versions.length > 0 ? searchResult.versions[0].changeId : undefined;
      if (!projectId || !repositoryId || !filePath || !changeId) {
        combinedResults.push({
          error: `Missing projectId, repositoryId, filePath, or changeId in the result: ${JSON.stringify(searchResult)}`,
        });
        continue;
      }

      const versionDescriptor = changeId
        ? { version: changeId, versionType: 2, versionOptions: 0 }
        : undefined;

      const item = await gitApi.getItem(
        repositoryId,
        filePath,
        projectId,
        undefined,
        VersionControlRecursionType.None,
        true, // includeContentMetadata
        false, // latestProcessedChange
        false, // download
        versionDescriptor,
        true, // includeContent
        true, // resolveLfs
        true  // sanitize
      );
      combinedResults.push({
        gitItem: item
      });
    } catch (err) {
      combinedResults.push({
        error: err instanceof Error ? err.message : String(err)
      });
    }
  }
  return combinedResults;
}

export { SEARCH_TOOLS, configureSearchTools };


================================================
FILE: src/tools/testplans.ts
================================================
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

import { AccessToken } from "@azure/identity";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { WebApi } from "azure-devops-node-api";
import { TestPlanCreateParams } from "azure-devops-node-api/interfaces/TestPlanInterfaces.js";
import { z } from "zod";

const Test_Plan_Tools = {
  create_test_plan: "testplan_create_test_plan",
  create_test_case: "testplan_create_test_case",
  add_test_cases_to_suite: "testplan_add_test_cases_to_suite",
  test_results_from_build_id: "testplan_show_test_results_from_build_id",
  list_test_cases: "testplan_list_test_cases",
  list_test_plans: "testplan_list_test_plans"
};

function configureTestPlanTools(
  server: McpServer,
  tokenProvider: () => Promise<AccessToken>,
  connectionProvider: () => Promise<WebApi>
) {
  /*
    LIST OF TEST PLANS
    get list of test plans by project
  */
  server.tool(
    Test_Plan_Tools.list_test_plans,
    "Retrieve a paginated list of test plans from an Azure DevOps project. Allows filtering for active plans and toggling detailed information.",
    {
      project: z.string().describe("The unique identifier (ID or name) of the Azure DevOps project."),
      filterActivePlans: z.boolean().default(true).describe("Filter to include only active test plans. Defaults to true."),
      includePlanDetails: z.boolean().default(false).describe("Include detailed information about each test plan."),
      continuationToken: z.string().optional().describe("Token to continue fetching test plans from a previous request."),
    },
    async ({
      project,
      filterActivePlans,
      includePlanDetails,
      continuationToken,
    }) => {
      const owner = ""; //making owner an empty string untill we can figure out how to get owner id
      const connection = await connectionProvider();
      const testPlanApi = await connection.getTestPlanApi();

      const testPlans = await testPlanApi.getTestPlans(
        project,
        owner,
        continuationToken,
        includePlanDetails,
        filterActivePlans
      );

      return {
        content: [{ type: "text", text: JSON.stringify(testPlans, null, 2) }],
      };
    }
  );

  /*
    Create Test Plan - CREATE
  */
  server.tool(
    Test_Plan_Tools.create_test_plan,
    "Creates a new test plan in the project.",
    {
      project: z.string().describe("The unique identifier (ID or name) of the Azure DevOps project where the test plan will be created."),
      name: z.string().describe("The name of the test plan to be created."),
      iteration: z.string().describe("The iteration path for the test plan"),
      description: z.string().optional().describe("The description of the test plan"),
      startDate: z.string().optional().describe("The start date of the test plan"),
      endDate: z.string().optional().describe("The end date of the test plan"),
      areaPath: z.string().optional().describe("The area path for the test plan"),
    },
    async ({
      project,
      name,
      iteration,
      description,
      startDate,
      endDate,
      areaPath,
    }) => {
      const connection = await connectionProvider();
      const testPlanApi = await connection.getTestPlanApi();

      const testPlanToCreate: TestPlanCreateParams = {
        name,
        iteration,
        description,
        startDate: startDate ? new Date(startDate) : undefined,
        endDate: endDate ? new Date(endDate) : undefined,
        areaPath,
      };

      const createdTestPlan = await testPlanApi.createTestPlan(
        testPlanToCreate,
        project
      );

      return {
        content: [
          { type: "text", text: JSON.stringify(createdTestPlan, null, 2) },
        ],
      };
    }
  );

  /*
    Add Test Cases to Suite - ADD
  */
  server.tool(
    Test_Plan_Tools.add_test_cases_to_suite,
    "Adds existing test cases to a test suite.",
    {
      project: z.string().describe("The unique identifier (ID or name) of the Azure DevOps project."),
      planId: z.number().describe("The ID of the test plan."),
      suiteId: z.number().describe("The ID of the test suite."),
      testCaseIds: z.string().or(z.array(z.string())).describe("The ID(s) of the test case(s) to add. "),
    },
    async ({ project, planId, suiteId, testCaseIds }) => {
      const connection = await connectionProvider();
      const testApi = await connection.getTestApi();

      // If testCaseIds is an array, convert it to comma-separated string
      const testCaseIdsString = Array.isArray(testCaseIds)
        ? testCaseIds.join(",")
        : testCaseIds;

      const addedTestCases = await testApi.addTestCasesToSuite(
        project,
        planId,
        suiteId,
        testCaseIdsString
      );

      return {
        content: [
          { type: "text", text: JSON.stringify(addedTestCases, null, 2) },
        ],
      };
    }
  );

  /*
    Create Test Case - CREATE
  */
  server.tool(
    Test_Plan_Tools.create_test_case,
    "Creates a new test case work item.",
    {
      project: z.string().describe("The unique identifier (ID or name) of the Azure DevOps project."),
      title: z.string().describe("The title of the test case."),
      steps: z.string().optional().describe("The steps to reproduce the test case. Make sure to format each step as '1. Step one\\n2. Step two' etc."),
      priority: z.number().optional().describe("The priority of the test case."),
      areaPath: z.string().optional().describe("The area path for the test case."),
      iterationPath: z.string().optional().describe("The iteration path for the test case."),
    },
    async ({ project, title, steps, priority, areaPath, iterationPath }) => {
      const connection = await connectionProvider();
      const witClient = await connection.getWorkItemTrackingApi();

      let stepsXml;
      if (steps) {
        stepsXml = convertStepsToXml(steps);
      }

      // Create JSON patch document for work item
      const patchDocument = [];

      patchDocument.push({
        op: "add",
        path: "/fields/System.Title",
        value: title,
      });

      if (stepsXml) {
        patchDocument.push({
          op: "add",
          path: "/fields/Microsoft.VSTS.TCM.Steps",
          value: stepsXml,
        });
      }

      if (priority) {
        patchDocument.push({
          op: "add",
          path: "/fields/Microsoft.VSTS.Common.Priority",
          value: priority,
        });
      }

      if (areaPath) {
        patchDocument.push({
          op: "add",
          path: "/fields/System.AreaPath",
          value: areaPath,
        });
      }

      if (iterationPath) {
        patchDocument.push({
          op: "add",
          path: "/fields/System.IterationPath",
          value: iterationPath,
        });
      }

      const workItem = await witClient.createWorkItem(
        {},
        patchDocument,
        project,
        "Test Case"
      );

      return {
        content: [{ type: "text", text: JSON.stringify(workItem, null, 2) }],
      };
    }
  );

  /* 
    TEST PLANS
    Gets a list of test cases for a given testplan.
  */
  server.tool(
    Test_Plan_Tools.list_test_cases,
    "Gets a list of test cases in the test plan.",
    {
      project: z.string().describe("The unique identifier (ID or name) of the Azure DevOps project."),
      planid: z.number().describe("The ID of the test plan."),
      suiteid: z.number().describe("The ID of the test suite."),
    },
    async ({ project, planid, suiteid }) => {
      const connection = await connectionProvider();
      const coreApi = await connection.getTestPlanApi();
      const testcases = await coreApi.getTestCaseList(project, planid, suiteid);

      return {
        content: [{ type: "text", text: JSON.stringify(testcases, null, 2) }],
      };
    }
  );

  /*
    Gets a list of test results for a given project and build ID
  */
  server.tool(
    Test_Plan_Tools.test_results_from_build_id,
    "Gets a list of test results for a given project and build ID.",
    {
      project: z.string().describe("The unique identifier (ID or name) of the Azure DevOps project."),
      buildid: z.number().describe("The ID of the build."),
    },
    async ({ project, buildid }) => {
      const connection = await connectionProvider();
      const coreApi = await connection.getTestResultsApi();
      const testResults = await coreApi.getTestResultDetailsForBuild(
        project,
        buildid
      );

      return {
        content: [{ type: "text", text: JSON.stringify(testResults, null, 2) }],
      };
    }
  );

}

/*
 * Helper function to convert steps text to XML format required
*/
function convertStepsToXml(steps: string): string {
  const stepsLines = steps.split("\n").filter((line) => line.trim() !== "");

  let xmlSteps = `<steps id="0" last="${stepsLines.length}">`;

  for (let i = 0; i < stepsLines.length; i++) {
    const stepLine = stepsLines[i].trim();
    if (stepLine) {
      const stepMatch = stepLine.match(/^(\d+)\.\s*(.+)$/);
      const stepText = stepMatch ? stepMatch[2] : stepLine;

      xmlSteps += `
                <step id="${i + 1}" type="ActionStep">
                    <parameterizedString isformatted="true">${escapeXml(
                      stepText
                    )}</parameterizedString>
                    <parameterizedString isformatted="true">Verify step completes successfully</parameterizedString>
                </step>`;
    }
  }

  xmlSteps += "</steps>";
  return xmlSteps;
}

/*
 * Helper function to escape XML special characters
*/
function escapeXml(unsafe: string): string {
  return unsafe.replace(/[<>&'"]/g, (c) => {
    switch (c) {
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case "&":
        return "&amp;";
      case "'":
        return "&apos;";
      case '"':
        return "&quot;";
      default:
        return c;
    }
  });
}

export { Test_Plan_Tools, configureTestPlanTools };



================================================
FILE: src/tools/wiki.ts
================================================
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

import { AccessToken } from "@azure/identity";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { WebApi } from "azure-devops-node-api";
import { z } from "zod";
import { WikiPagesBatchRequest } from "azure-devops-node-api/interfaces/WikiInterfaces.js";

const WIKI_TOOLS = {
  list_wikis: "wiki_list_wikis",
  get_wiki: "wiki_get_wiki",
  list_wiki_pages: "wiki_list_pages",
  get_wiki_page_content: "wiki_get_page_content",
};

function configureWikiTools(
  server: McpServer,
  tokenProvider: () => Promise<AccessToken>,
  connectionProvider: () => Promise<WebApi>
) {
  server.tool(
    WIKI_TOOLS.get_wiki,
    "Get the wiki by wikiIdentifier",
    {
      wikiIdentifier: z.string().describe("The unique identifier of the wiki."),
      project: z.string().optional().describe("The project name or ID where the wiki is located. If not provided, the default project will be used."),
    },
    async ({ wikiIdentifier, project }) => {
      try {
        const connection = await connectionProvider();
        const wikiApi = await connection.getWikiApi();
        const wiki = await wikiApi.getWiki(wikiIdentifier, project);

        if (!wiki) {
          return { content: [{ type: "text", text: "No wiki found" }], isError: true };
        }

        return {
          content: [{ type: "text", text: JSON.stringify(wiki, null, 2) }],
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        
        return { 
          content: [{ type: "text", text: `Error fetching wiki: ${errorMessage}` }], 
          isError: true
        };
      }
    }
  );

  server.tool(
    WIKI_TOOLS.list_wikis,
    "Retrieve a list of wikis for an organization or project.",
    {
      project: z.string().optional().describe("The project name or ID to filter wikis. If not provided, all wikis in the organization will be returned."),
    },
    async ({ project }) => {
      try {
        const connection = await connectionProvider();
        const wikiApi = await connection.getWikiApi();
        const wikis = await wikiApi.getAllWikis(project);

        if (!wikis) {
          return { content: [{ type: "text", text: "No wikis found" }], isError: true };
        }

        return {
          content: [{ type: "text", text: JSON.stringify(wikis, null, 2) }],
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        
        return { 
          content: [{ type: "text", text: `Error fetching wikis: ${errorMessage}` }], 
          isError: true
        };
      }
    }
  );

  server.tool(
    WIKI_TOOLS.list_wiki_pages,
    "Retrieve a list of wiki pages for a specific wiki and project.",
    {
      wikiIdentifier: z.string().describe("The unique identifier of the wiki."),
      project: z.string().describe("The project name or ID where the wiki is located."),
      top: z.number().default(20).describe("The maximum number of pages to return. Defaults to 20."),
      continuationToken: z.string().optional().describe("Token for pagination to retrieve the next set of pages."),
      pageViewsForDays: z.number().optional().describe("Number of days to retrieve page views for. If not specified, page views are not included."),
    },
    async ({
      wikiIdentifier,
      project,
      top = 20,
      continuationToken,
      pageViewsForDays,
    }) => {
      try {
        const connection = await connectionProvider();
        const wikiApi = await connection.getWikiApi();

        const pagesBatchRequest: WikiPagesBatchRequest = {
          top,
          continuationToken,
          pageViewsForDays,
        };

        const pages = await wikiApi.getPagesBatch(
          pagesBatchRequest,
          project,
          wikiIdentifier
        );

        if (!pages) {
          return { content: [{ type: "text", text: "No wiki pages found" }], isError: true };
        }

        return {
          content: [{ type: "text", text: JSON.stringify(pages, null, 2) }],
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        
        return { 
          content: [{ type: "text", text: `Error fetching wiki pages: ${errorMessage}` }], 
          isError: true
        };
      }
    }
  );

  server.tool(
    WIKI_TOOLS.get_wiki_page_content,
    "Retrieve wiki page content by wikiIdentifier and path.",
    {
      wikiIdentifier: z.string().describe("The unique identifier of the wiki."),
      project: z.string().describe("The project name or ID where the wiki is located."),
      path: z.string().describe("The path of the wiki page to retrieve content for."),
    },
    async ({ wikiIdentifier, project, path }) => {
      try {
        const connection = await connectionProvider();
        const wikiApi = await connection.getWikiApi();

        const stream = await wikiApi.getPageText(
          project,
          wikiIdentifier,
          path,
          undefined,
          undefined,
          true
        );

        if (!stream) {
          return { content: [{ type: "text", text: "No wiki page content found" }], isError: true };
        }

        const content = await streamToString(stream);

        return {
          content: [{ type: "text", text: JSON.stringify(content, null, 2) }],
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        
        return { 
          content: [{ type: "text", text: `Error fetching wiki page content: ${errorMessage}` }], 
          isError: true
        };
      }
    }
  );
}

function streamToString(stream: NodeJS.ReadableStream): Promise<string> {
  return new Promise((resolve, reject) => {
    let data = "";
    stream.setEncoding("utf8");
    stream.on("data", (chunk) => (data += chunk));
    stream.on("end", () => resolve(data));
    stream.on("error", reject);
  });
}

export { WIKI_TOOLS, configureWikiTools };



================================================
FILE: src/tools/work.ts
================================================
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

import { AccessToken } from "@azure/identity";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { WebApi } from "azure-devops-node-api";
import { z } from "zod";
import { TreeStructureGroup } from "azure-devops-node-api/interfaces/WorkItemTrackingInterfaces.js";

const WORK_TOOLS = { 
  list_team_iterations: "work_list_team_iterations",
  create_iterations: "work_create_iterations",
  assign_iterations: "work_assign_iterations",
};

function configureWorkTools(
  server: McpServer,
  tokenProvider: () => Promise<AccessToken>,
  connectionProvider: () => Promise<WebApi>
) {  

  server.tool(
    WORK_TOOLS.list_team_iterations,
    "Retrieve a list of iterations for a specific team in a project.",     
    {
      project: z.string().describe("The name or ID of the Azure DevOps project."),
      team: z.string().describe("The name or ID of the Azure DevOps team."),
      timeframe: z.enum(["current"]).optional().describe("The timeframe for which to retrieve iterations. Currently, only 'current' is supported."),
    },
    async ({ project, team, timeframe }) => {
      try {
        const connection = await connectionProvider();
        const workApi = await connection.getWorkApi();
        const iterations = await workApi.getTeamIterations(
          { project, team },
          timeframe
        );

        if (!iterations) {
          return { content: [{ type: "text", text: "No iterations found" }], isError: true };
        }

        return {
          content: [{ type: "text", text: JSON.stringify(iterations, null, 2) }],
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        
        return { 
          content: [{ type: "text", text: `Error fetching team iterations: ${errorMessage}` }], 
          isError: true
        };
      }
    }
  );

  server.tool(
    WORK_TOOLS.create_iterations,
    "Create new iterations in a specified Azure DevOps project.",     
    {
      project: z.string().describe("The name or ID of the Azure DevOps project."),
      iterations: z.array(z.object({
        iterationName: z.string().describe("The name of the iteration to create."),
        startDate: z.string().optional().describe("The start date of the iteration in ISO format (e.g., '2023-01-01T00:00:00Z'). Optional."),
        finishDate: z.string().optional().describe("The finish date of the iteration in ISO format (e.g., '2023-01-31T23:59:59Z'). Optional.")
      })).describe("An array of iterations to create. Each iteration must have a name and can optionally have start and finish dates in ISO format.")
    },
    async ({ project, iterations }) => {
      try {
        const connection = await connectionProvider();
        const workItemTrackingApi = await connection.getWorkItemTrackingApi();
        const results = [];

        for (const { iterationName, startDate, finishDate } of iterations) {
          // Step 1: Create the iteration
          const iteration = await workItemTrackingApi.createOrUpdateClassificationNode(
            {
              name: iterationName,
              attributes: {
                startDate: startDate ? new Date(startDate) : undefined,
                finishDate: finishDate ? new Date(finishDate) : undefined,
              },
            },
            project,
            TreeStructureGroup.Iterations
          );
          
          if (iteration) {
            results.push(iteration);
          }
        }
        
        if (results.length === 0) {
          return { content: [{ type: "text", text: "No iterations were created" }], isError: true };
        }

        return {
          content: [{ type: "text", text: JSON.stringify(results, null, 2) }],
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        
        return { 
          content: [{ type: "text", text: `Error creating iterations: ${errorMessage}` }], 
          isError: true
        };
      }
    }
  );
  
  server.tool(
    WORK_TOOLS.assign_iterations,
    "Assign existing iterations to a specific team in a project.",  
    {
      project: z.string().describe("The name or ID of the Azure DevOps project."),
      team: z.string().describe("The name or ID of the Azure DevOps team."),
      iterations: z.array(z.object({
        identifier: z.string().describe("The identifier of the iteration to assign."),
        path: z.string().describe("The path of the iteration to assign, e.g., 'Project/Iteration'.")
      })).describe("An array of iterations to assign. Each iteration must have an identifier and a path."),
    },
    async ({ project, team, iterations }) => {
      try {
        const connection = await connectionProvider();
        const workApi = await connection.getWorkApi();
        const teamContext = { project, team };
        const results = [];
        
        for (const { identifier, path } of iterations) {
          const assignment = await workApi.postTeamIteration(
            { path: path, id: identifier },
            teamContext
          );

          if (assignment) {
            results.push(assignment);
          }
        }
        
        if (results.length === 0) {
          return { content: [{ type: "text", text: "No iterations were assigned to the team" }], isError: true };
        }

        return {
          content: [{ type: "text", text: JSON.stringify(results, null, 2) }],
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        
        return { 
          content: [{ type: "text", text: `Error assigning iterations: ${errorMessage}` }], 
          isError: true
        };
      }
    }
  );
 
}

export { WORK_TOOLS, configureWorkTools };



================================================
FILE: src/tools/workitems.ts
================================================
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

import { AccessToken } from "@azure/identity";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { WebApi } from "azure-devops-node-api";
import { WorkItemExpand } from "azure-devops-node-api/interfaces/WorkItemTrackingInterfaces.js";
import { QueryExpand } from "azure-devops-node-api/interfaces/WorkItemTrackingInterfaces.js";
import { z } from "zod";
import { batchApiVersion, userAgent } from "../utils.js";

const WORKITEM_TOOLS = {
  my_work_items: "wit_my_work_items",
  list_backlogs: "wit_list_backlogs",    
  list_backlog_work_items: "wit_list_backlog_work_items",   
  get_work_item: "wit_get_work_item",
  get_work_items_batch_by_ids: "wit_get_work_items_batch_by_ids",
  update_work_item: "wit_update_work_item",
  create_work_item: "wit_create_work_item",
  list_work_item_comments: "wit_list_work_item_comments",
  get_work_items_for_iteration: "wit_get_work_items_for_iteration",
  add_work_item_comment: "wit_add_work_item_comment",
  add_child_work_item: "wit_add_child_work_item",
  link_work_item_to_pull_request: "wit_link_work_item_to_pull_request",
  get_work_item_type: "wit_get_work_item_type",
  get_query: "wit_get_query", 
  get_query_results_by_id: "wit_get_query_results_by_id",
  update_work_items_batch: "wit_update_work_items_batch",
  close_and_link_workitem_duplicates: "wit_close_and_link_workitem_duplicates",
  work_items_link: "wit_work_items_link"
};

function getLinkTypeFromName(name: string) {
  switch (name.toLowerCase()) {
    case "parent":
      return "System.LinkTypes.Hierarchy-Reverse";
    case "child":
      return "System.LinkTypes.Hierarchy-Forward";
    case "duplicate":
      return "System.LinkTypes.Duplicate-Forward";
    case "duplicate of":
      return "System.LinkTypes.Duplicate-Reverse";
    case "related":
      return "System.LinkTypes.Related";
    case "successor":
      return "System.LinkTypes.Dependency-Forward";
    case "predecessor":
      return "System.LinkTypes.Dependency-Reverse";
    case "tested by":
      return "Microsoft.VSTS.Common.TestedBy-Forward";
    case "tests":
      return "Microsoft.VSTS.Common.TestedBy-Reverse";
    default:
      throw new Error(`Unknown link type: ${name}`);
  }
}

function configureWorkItemTools(
  server: McpServer,
  tokenProvider: () => Promise<AccessToken>,
  connectionProvider: () => Promise<WebApi>
) {
  
  server.tool(
    WORKITEM_TOOLS.list_backlogs,
    "Revieve a list of backlogs for a given project and team.",
    { 
      project: z.string().describe("The name or ID of the Azure DevOps project."), 
      team: z.string().describe("The name or ID of the Azure DevOps team.") 
    },
    async ({ project, team }) => {
      const connection = await connectionProvider();
      const workApi = await connection.getWorkApi();
      const teamContext = { project, team };
      const backlogs = await workApi.getBacklogs(teamContext);

      return {
        content: [{ type: "text", text: JSON.stringify(backlogs, null, 2) }],
      };
    }
  );
 
  server.tool(
    WORKITEM_TOOLS.list_backlog_work_items,
    "Retrieve a list of backlogs of for a given project, team, and backlog category",
    { 
      project: z.string().describe("The name or ID of the Azure DevOps project."), 
      team: z.string().describe("The name or ID of the Azure DevOps team."), 
      backlogId: z.string().describe("The ID of the backlog category to retrieve work items from.") 
    },
    async ({ project, team, backlogId }) => {
      const connection = await connectionProvider();
      const workApi = await connection.getWorkApi();
      const teamContext = { project, team };

      const workItems = await workApi.getBacklogLevelWorkItems(
        teamContext,
        backlogId
      );

      return {
        content: [{ type: "text", text: JSON.stringify(workItems, null, 2) }],
      };
    }
  );
 
  server.tool(
    WORKITEM_TOOLS.my_work_items,
    "Retrieve a list of work items relevent to the authenticated user.",
    {
      project: z.string().describe("The name or ID of the Azure DevOps project."),
      type: z.enum(["assignedtome", "myactivity"]).default("assignedtome").describe("The type of work items to retrieve. Defaults to 'assignedtome'."),
      top: z.number().default(50).describe("The maximum number of work items to return. Defaults to 50."),
      includeCompleted: z.boolean().default(false).describe("Whether to include completed work items. Defaults to false."),
    },
    async ({ project, type, top, includeCompleted }) => {
      const connection = await connectionProvider();
      const workApi = await connection.getWorkApi();

      const workItems = await workApi.getPredefinedQueryResults(
        project,
        type,
        top,
        includeCompleted
      );

      return {
        content: [{ type: "text", text: JSON.stringify(workItems, null, 2) }],
      };
    }
  );
 
  server.tool(
    WORKITEM_TOOLS.get_work_items_batch_by_ids,
    "Retrieve list of work items by IDs in batch.",
    { 
      project: z.string().describe("The name or ID of the Azure DevOps project."), 
      ids: z.array(z.number()).describe("The IDs of the work items to retrieve.")
    },
    async ({ project, ids }) => {
      const connection = await connectionProvider();
      const workItemApi = await connection.getWorkItemTrackingApi();
      const fields = ["System.Id", "System.WorkItemType", "System.Title", "System.State", "System.Parent", "System.Tags"];
      const workitems = await workItemApi.getWorkItemsBatch({ids, fields}, project);

      return {
        content: [{ type: "text", text: JSON.stringify(workitems, null, 2) }],
      };
    }
  );
  
  server.tool(
    WORKITEM_TOOLS.get_work_item,
    "Get a single work item by ID.",
    {
      id: z.number().describe("The ID of the work item to retrieve."),
      project: z.string().describe("The name or ID of the Azure DevOps project."),
      fields: z.array(z.string()).optional().describe("Optional list of fields to include in the response. If not provided, all fields will be returned."),
      asOf: z.coerce.date().optional().describe("Optional date string to retrieve the work item as of a specific time. If not provided, the current state will be returned."),
      expand: z
        .enum(["all", "fields", "links", "none", "relations"])
        .describe("Optional expand parameter to include additional details in the response.")
        .optional().describe("Expand options include 'all', 'fields', 'links', 'none', and 'relations'. Defaults to 'none'."),
    },
    async ({ id, project, fields, asOf, expand }) => {
      const connection = await connectionProvider();
      const workItemApi = await connection.getWorkItemTrackingApi();
      const workItem = await workItemApi.getWorkItem(
        id,
        fields,
        asOf,
        expand as unknown as WorkItemExpand,
        project
      );
      return {
        content: [{ type: "text", text: JSON.stringify(workItem, null, 2) }],
      };
    }
  );
  
  server.tool(
    WORKITEM_TOOLS.list_work_item_comments,
    "Retrieve list of comments for a work item by ID.",
    { 
      project: z.string().describe("The name or ID of the Azure DevOps project."), 
      workItemId: z.number().describe("The ID of the work item to retrieve comments for."), 
      top: z.number().default(50).describe("Optional number of comments to retrieve. Defaults to all comments.") 
    },
    async ({ project, workItemId, top }) => {
      const connection = await connectionProvider();
      const workItemApi = await connection.getWorkItemTrackingApi();
      const comments = await workItemApi.getComments(project, workItemId, top);

      return {
        content: [{ type: "text", text: JSON.stringify(comments, null, 2) }],
      };
    }
  );
 
  server.tool(
    WORKITEM_TOOLS.add_work_item_comment,
    "Add comment to a work item by ID.",
    { 
      project: z.string().describe("The name or ID of the Azure DevOps project."), 
      workItemId: z.number().describe("The ID of the work item to add a comment to."), 
      comment: z.string().describe("The text of the comment to add to the work item.") 
    },
    async ({ project, workItemId, comment }) => {
      const connection = await connectionProvider();
      const workItemApi = await connection.getWorkItemTrackingApi();
      const commentCreate = { text: comment };
      const commentResponse = await workItemApi.addComment(
        commentCreate,
        project,
        workItemId
      );

      return {
        content: [
          { type: "text", text: JSON.stringify(commentResponse, null, 2) },
        ],
      };
    }
  ); 

 
  server.tool(
      WORKITEM_TOOLS.add_child_work_item,
      "Create a child work item from a parent by ID.",
      {
        parentId: z.number().describe("The ID of the parent work item to create a child work item under."),
        project: z.string().describe("The name or ID of the Azure DevOps project."),
        workItemType: z.string().describe("The type of the child work item to create."),
        title: z.string().describe("The title of the child work item."),
        description: z.string().describe("The description of the child work item."),
        areaPath: z.string().optional().describe("Optional area path for the child work item."),
        iterationPath: z.string().optional().describe("Optional iteration path for the child work item."),
      },
      async ({
        parentId,
        project,
        workItemType,
        title,
        description,
        areaPath,
        iterationPath,
      }) => {
        const connection = await connectionProvider();
        const workItemApi = await connection.getWorkItemTrackingApi();
  
        const document = [
          { 
            op: "add", 
            path: "/fields/System.Title", 
            value: title 
          },
          { 
            op: "add", 
            path: "/fields/System.Description", 
            value: description 
          },       
          {
            op: "add",
            path: "/relations/-",
            value: {
              rel: "System.LinkTypes.Hierarchy-Reverse",
              url: `${connection.serverUrl}/${project}/_apis/wit/workItems/${parentId}`,
            },
          },
        ];
  
        if (areaPath && areaPath.trim().length > 0) {
          document.push({
            op: "add",
            path: "/fields/System.AreaPath",
            value: areaPath,
          });
        }
  
        if (iterationPath && iterationPath.trim().length > 0) {
          document.push({
            op: "add",
            path: "/fields/System.IterationPath",
            value: iterationPath,
          });
        }
  
        const childWorkItem = await workItemApi.createWorkItem(
          null,
          document,
          project,
          workItemType
        );
  
        return {
          content: [
            { type: "text", text: JSON.stringify(childWorkItem, null, 2) },
          ],
        };
      }
    );
  
  server.tool(
    WORKITEM_TOOLS.link_work_item_to_pull_request,
    "Link a single work item to an existing pull request.",
    {
      project: z.string().describe("The name or ID of the Azure DevOps project."),
      repositoryId: z.string().describe("The ID of the repository containing the pull request. Do not use the repository name here, use the ID instead."),
      pullRequestId: z.number().describe("The ID of the pull request to link to."),
      workItemId: z.number().describe("The ID of the work item to link to the pull request."),
    },
    async ({ project, repositoryId, pullRequestId, workItemId }) => {
      try {
        const connection = await connectionProvider();
        const workItemTrackingApi = await connection.getWorkItemTrackingApi();
            
        // Create artifact link relation using vstfs format
        // Format: vstfs:///Git/PullRequestId/{project}/{repositoryId}/{pullRequestId}
        const artifactPathValue = `${project}/${repositoryId}/${pullRequestId}`;
        const vstfsUrl = `vstfs:///Git/PullRequestId/${encodeURIComponent(artifactPathValue)}`;

        // Use the PATCH document format for adding a relation
        const patchDocument = [
          {
            op: "add",
            path: "/relations/-",
            value: {
              rel: "ArtifactLink",
              url: vstfsUrl,
              attributes: {
                name: "Pull Request",
              },
            },
          },
        ];

        // Use the WorkItem API to update the work item with the new relation
        const workItem = await workItemTrackingApi.updateWorkItem(
          {},
          patchDocument,
          workItemId,
          project
        );

        if (!workItem) {
          return { content: [{ type: "text", text: "Work item update failed" }], isError: true };
        }

        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(
                {
                  workItemId,
                  pullRequestId,
                  success: true,
                },
                null,
                2
              ),
            },
          ],
        };
       } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        
        return { 
          content: [{ type: "text", text: `Error linking work item to pull request: ${errorMessage}` }], 
          isError: true
        };
      }
    }
  );  
  
  server.tool(
    WORKITEM_TOOLS.get_work_items_for_iteration,
    "Retrieve a list of work items for a specified iteration.",
    {
      project: z.string().describe("The name or ID of the Azure DevOps project."),
      team: z.string().optional().describe("The name or ID of the Azure DevOps team. If not provided, the default team will be used."),
      iterationId: z.string().describe("The ID of the iteration to retrieve work items for."),
    },
    async ({ project, team, iterationId }) => {
      const connection = await connectionProvider();
      const workApi = await connection.getWorkApi();

      //get the work items for the current iteration
      const workItems = await workApi.getIterationWorkItems(
        { project, team },
        iterationId
      );

      return {
        content: [{ type: "text", text: JSON.stringify(workItems, null, 2) }],
      };
    }
  );
 
  server.tool(
    WORKITEM_TOOLS.update_work_item,
    "Update a work item by ID with specified fields.",
    {
      id: z.number().describe("The ID of the work item to update."),
      updates: z.array(
        z.object({
          op: z.enum(["add", "replace", "remove"]).default("add").describe("The operation to perform on the field."),
          path: z.string().describe("The path of the field to update, e.g., '/fields/System.Title'."),
          value: z.string().describe("The new value for the field. This is required for 'add' and 'replace' operations, and should be omitted for 'remove' operations."),
        })
      ).describe("An array of field updates to apply to the work item."),
    },
    async ({ id, updates }) => {
      const connection = await connectionProvider();
      const workItemApi = await connection.getWorkItemTrackingApi();
      const updatedWorkItem = await workItemApi.updateWorkItem(
        null,
        updates,
        id
      );

      return {
        content: [
          { type: "text", text: JSON.stringify(updatedWorkItem, null, 2) },
        ],
      };
    }
  );
 
  server.tool(
    WORKITEM_TOOLS.get_work_item_type,
    "Get a specific work item type.",
    {
      project: z.string().describe("The name or ID of the Azure DevOps project."),
      workItemType: z.string().describe("The name of the work item type to retrieve."),
    },
    async ({ project, workItemType }) => {
      const connection = await connectionProvider();
      const workItemApi = await connection.getWorkItemTrackingApi();

      const workItemTypeInfo = await workItemApi.getWorkItemType(
        project,
        workItemType
      );

      return {
        content: [
          { type: "text", text: JSON.stringify(workItemTypeInfo, null, 2) },
        ],
      };
    }
  );
 
  server.tool(
    WORKITEM_TOOLS.create_work_item,
    "Create a new work item in a specified project and work item type.",
    {
      project: z.string().describe("The name or ID of the Azure DevOps project."),
      workItemType: z.string().describe("The type of work item to create, e.g., 'Task', 'Bug', etc."),
      fields: z.record(z.string(), z.string()).describe("A record of field names and values to set on the new work item. Each key is a field name, and each value is the corresponding value to set for that field."),
    },
    async ({ project, workItemType, fields }) => {
      try {
        const connection = await connectionProvider();
        const workItemApi = await connection.getWorkItemTrackingApi();

        const document = Object.entries(fields).map(([key, value]) => ({
          op: "add",
          path: `/fields/${key}`,
          value,
        }));

        const newWorkItem = await workItemApi.createWorkItem(
          null,
          document,
          project,
          workItemType
        );

        if (! newWorkItem) {
          return { content: [{ type: "text", text: "Work item was not created" }], isError: true };
        }

        return {
          content: [{ type: "text", text: JSON.stringify(newWorkItem, null, 2) }],
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        
        return { 
          content: [{ type: "text", text: `Error creating work item: ${errorMessage}` }], 
          isError: true
        };
      }
    }
  );
  
  server.tool(
    WORKITEM_TOOLS.get_query,
    "Get a query by its ID or path.",
    {
      project: z.string().describe("The name or ID of the Azure DevOps project."),
      query: z.string().describe("The ID or path of the query to retrieve."),
      expand: z.enum(["all", "clauses", "minimal", "none", "wiql"]).optional().describe("Optional expand parameter to include additional details in the response. Defaults to 'none'."),
      depth: z.number().default(0).describe("Optional depth parameter to specify how deep to expand the query. Defaults to 0."),
      includeDeleted: z.boolean().default(false).describe("Whether to include deleted items in the query results. Defaults to false."),
      useIsoDateFormat: z.boolean().default(false).describe("Whether to use ISO date format in the response. Defaults to false."),
    },
    async ({
      project,
      query,
      expand,
      depth,
      includeDeleted,
      useIsoDateFormat,
    }) => {
      const connection = await connectionProvider();
      const workItemApi = await connection.getWorkItemTrackingApi();

      const queryDetails = await workItemApi.getQuery(
        project,
        query,
        expand as unknown as QueryExpand,
        depth,
        includeDeleted,
        useIsoDateFormat
      );

      return {
        content: [
          { type: "text", text: JSON.stringify(queryDetails, null, 2) },
        ],
      };
    }
  );

  server.tool(
    WORKITEM_TOOLS.get_query_results_by_id,
    "Retrieve the results of a work item query given the query ID.",
    {
      id: z.string().describe("The ID of the query to retrieve results for."),
      project: z.string().optional().describe("The name or ID of the Azure DevOps project. If not provided, the default project will be used."),
      team: z.string().optional().describe("The name or ID of the Azure DevOps team. If not provided, the default team will be used."),
      timePrecision: z.boolean().optional().describe("Whether to include time precision in the results. Defaults to false."),
      top: z.number().default(50).describe("The maximum number of results to return. Defaults to 50."),
    },
    async ({ id, project, team, timePrecision, top }) => {
      const connection = await connectionProvider();
      const workItemApi = await connection.getWorkItemTrackingApi();
      const teamContext = { project, team };
      const queryResult = await workItemApi.queryById(
        id,
        teamContext,
        timePrecision,
        top
      );

      return {
        content: [{ type: "text", text: JSON.stringify(queryResult, null, 2) }],
      };
    }
  );
 
  server.tool(
    WORKITEM_TOOLS.update_work_items_batch,
    "Update work items in batch",
    {
      updates: z.array(
        z.object({
          op: z.enum(["add", "replace", "remove"]).default("add").describe("The operation to perform on the field."),
          id: z.number().describe("The ID of the work item to update."),
          path: z.string().describe("The path of the field to update, e.g., '/fields/System.Title'."),
          value: z.string().describe("The new value for the field. This is required for 'add' and 'replace' operations, and should be omitted for 'remove' operations."),
        })
      ).describe("An array of updates to apply to work items. Each update should include the operation (op), work item ID (id), field path (path), and new value (value)."),
    },
    async ({ updates }) => {
      const connection = await connectionProvider();
      const orgUrl = connection.serverUrl;
      const accessToken = await tokenProvider();

      // Extract unique IDs from the updates array
      const uniqueIds = Array.from(new Set(updates.map((update) => update.id)));

      const body = uniqueIds.map((id) => ({
        method: "PATCH",
        uri: `/_apis/wit/workitems/${id}?api-version=${batchApiVersion}`,
        headers: {
          "Content-Type": "application/json-patch+json",
        },
        body: updates.filter((update) => update.id === id).map(({ op, path, value }) => ({
            op: op,
            path: path,
            value: value,
          })),
      }));     

      const response = await fetch(
        `${orgUrl}/_apis/wit/$batch?api-version=${batchApiVersion}`,
        {
          method: "PATCH",
          headers: {
            Authorization: `Bearer ${accessToken.token}`,
            "Content-Type": "application/json",
            "User-Agent": `${userAgent}`,
          },
          body: JSON.stringify(body),
        }
      );

      if (!response.ok) {
        throw new Error(
          `Failed to update work items in batch: ${response.statusText}`
        );
      }

      const result = await response.json();

      return {
        content: [{ type: "text", text: JSON.stringify(result, null, 2) }],
      };
    }
  );

  server.tool(
    WORKITEM_TOOLS.work_items_link,
    "Link work items together in batch.",
    {
      project: z.string().describe("The name or ID of the Azure DevOps project."),
      updates: z.array(
        z.object({
          id: z.number().describe("The ID of the work item to update."),
          linkToId: z.number().describe("The ID of the work item to link to."),
          type: z.enum(["parent", "child", "duplicate", "duplicate of", "related", "successor", "predecessor", "tested by", "tests"]).default("related").describe("Type of link to create between the work items. Options include 'parent', 'child', 'duplicate', 'duplicate of', 'related', 'successor', 'predecessor', 'tested by', 'tests', 'referenced by', and 'references'. Defaults to 'related'."),             
          comment: z.string().optional().describe("Optional comment to include with the link. This can be used to provide additional context for the link being created."),
        })
      ).describe(""),
    },
    async ({ project, updates }) => {
      const connection = await connectionProvider();
      const orgUrl = connection.serverUrl;
      const accessToken = await tokenProvider();

      // Extract unique IDs from the updates array
      const uniqueIds = Array.from(new Set(updates.map((update) => update.id)));

      const body = uniqueIds.map((id) => ({
        method: "PATCH",
        uri: `/_apis/wit/workitems/${id}?api-version=${batchApiVersion}`,
        headers: {
          "Content-Type": "application/json-patch+json",
        },
        body: updates.filter((update) => update.id === id).map(({ linkToId, type, comment }) => ({
            op: "add",
            path: "/relations/-",
            value: {
              rel: `${getLinkTypeFromName(type)}`,
              url: `${orgUrl}/${project}/_apis/wit/workItems/${linkToId}`,
              attributes: {
                comment: comment || "",
              },
            }
          })),
      }));     

      const response = await fetch(
        `${orgUrl}/_apis/wit/$batch?api-version=${batchApiVersion}`,
        {
          method: "PATCH",
          headers: {
            Authorization: `Bearer ${accessToken.token}`,
            "Content-Type": "application/json",
            "User-Agent": `${userAgent}`,
          },
          body: JSON.stringify(body),
        }
      );

      if (!response.ok) {
        throw new Error(
          `Failed to update work items in batch: ${response.statusText}`
        );
      }

      const result = await response.json();

      return {
        content: [{ type: "text", text: JSON.stringify(result, null, 2) }],
      };
    }
  );
 
  server.tool (
    WORKITEM_TOOLS.close_and_link_workitem_duplicates,
    "Close duplicate work items by id.",
    {
      id: z.number().describe("The ID of the work item to close and link duplicates to."),
      duplicateIds: z.array(z.number()).describe("An array of IDs of the duplicate work items to close and link to the specified work item."),
      project: z.string().describe("The name or ID of the Azure DevOps project."),
      state: z.string().default("Removed").describe("The state to set for the duplicate work items. Defaults to 'Removed'."),
    },
    async ({ id, duplicateIds, project, state }) => {
      const connection = await connectionProvider();

      const body = duplicateIds.map((duplicateId) => ({
        method: "PATCH",
        uri: `/_apis/wit/workitems/${duplicateId}?api-version=${batchApiVersion}`,
        headers: {
          "Content-Type": "application/json-patch+json",
        },
        body: [
          {
            op: "add",
            path: "/fields/System.State",
            value: `${state}`,
          },
          {
            op: "add",
            path: "/relations/-",
            value: {
              rel: "System.LinkTypes.Duplicate-Reverse",
              url: `${connection.serverUrl}/${project}/_apis/wit/workItems/${id}`,
            },
          },
        ],
      }));

      const accessToken = await tokenProvider();

      const response = await fetch(
        `${connection.serverUrl}/_apis/wit/$batch?api-version=${batchApiVersion}`,
        {
          method: "PATCH",
          headers: {
            Authorization: `Bearer ${accessToken.token}`,
            "Content-Type": "application/json",
            "User-Agent": `${userAgent}`,
          },
          body: JSON.stringify(body),
        }
      );

      if (!response.ok) {
        throw new Error(
          `Failed to update work items in batch: ${response.statusText}`
        );
      }

      const result = await response.json();

      return {
        content: [{ type: "text", text: JSON.stringify(result, null, 2) }],
      };
    }
  );
}

export { WORKITEM_TOOLS, configureWorkItemTools };



================================================
FILE: test/mocks/work-items.ts
================================================

export const _mockWorkItems = {
  count: 3,
  value: [
    {
      id: 297,
      rev: 1,
      fields: {
        "System.Id": 297,
        "System.WorkItemType": "Product Backlog Item",
        "System.Title": "Customer can sign in using their Microsoft Account",
      },
      url: "https://dev.azure.com/fabrikam/_apis/wit/workItems/297",
    },
    {
      id: 299,
      rev: 7,
      fields: {
        "System.Id": 299,
        "System.WorkItemType": "Task",
        "System.Title": "JavaScript implementation for Microsoft Account",
        "Microsoft.VSTS.Scheduling.RemainingWork": 4,
      },
      url: "https://dev.azure.com/fabrikam/_apis/wit/workItems/299",
    },
    {
      id: 301,
      rev: 1,
      fields: {
        "System.Id": 301,
        "System.WorkItemType": "Task",
        "System.Title": "Unit Testing for MSA login",
        "Microsoft.VSTS.Scheduling.RemainingWork": 3,
      },
      url: "https://dev.azure.com/fabrikam/_apis/wit/workItems/300",
    },
  ],
};

export const _mockBacklogs = {
  count: 2,
  value: [
    {
      id: "Microsoft.EpicCategory",
      name: "Epics",
      rank: 4,
      workItemCountLimit: 1000,
      addPanelFields: [
        {
          referenceName: "System.Title",
          name: "Title",
          url: "https://dev.azure.com/fabrikam/_apis/wit/fields/System.Title",
        },
      ],
      columnFields: [
        {
          columnFieldReference: {
            referenceName: "System.WorkItemType",
            name: "Work Item Type",
            url: "https://dev.azure.com/fabrikam/_apis/wit/fields/System.WorkItemType",
          },
          width: 100,
        },
        {
          columnFieldReference: {
            referenceName: "System.Title",
            name: "Title",
            url: "https://dev.azure.com/fabrikam/_apis/wit/fields/System.Title",
          },
          width: 400,
        },
        {
          columnFieldReference: {
            referenceName: "System.State",
            name: "State",
            url: "https://dev.azure.com/fabrikam/_apis/wit/fields/System.State",
          },
          width: 100,
        },
        {
          columnFieldReference: {
            referenceName: "Microsoft.VSTS.Scheduling.Effort",
            name: "Effort",
            url: "https://dev.azure.com/fabrikam/_apis/wit/fields/Microsoft.VSTS.Scheduling.Effort",
          },
          width: 50,
        },        
        {
          columnFieldReference: {
            referenceName: "System.Tags",
            name: "Tags",
            url: "https://dev.azure.com/fabrikam/_apis/wit/fields/System.Tags",
          },
          width: 200,
        },
      ],
      workItemTypes: [
        {
          name: "Epic",
          url: "https://dev.azure.com/fabrikam/Fabrikam-Fiber/_apis/wit/workItemTypes/Epic",
        },
      ],
      defaultWorkItemType: {
        name: "Epic",
        url: "https://dev.azure.com/fabrikam/Fabrikam-Fiber/_apis/wit/workItemTypes/Epic",
      },
      color: "FF7B00",
      isHidden: false,
      type: "portfolio",
    },
    {
      id: "Microsoft.FeatureCategory",
      name: "Features",
      rank: 3,
      workItemCountLimit: 1000,
      addPanelFields: [
        {
          referenceName: "System.Title",
          name: "Title",
          url: "https://dev.azure.com/fabrikam/_apis/wit/fields/System.Title",
        },
      ],
      columnFields: [
        {
          columnFieldReference: {
            referenceName: "System.WorkItemType",
            name: "Work Item Type",
            url: "https://dev.azure.com/fabrikam/_apis/wit/fields/System.WorkItemType",
          },
          width: 100,
        },
        {
          columnFieldReference: {
            referenceName: "System.Title",
            name: "Title",
            url: "https://dev.azure.com/fabrikam/_apis/wit/fields/System.Title",
          },
          width: 400,
        },
        {
          columnFieldReference: {
            referenceName: "System.State",
            name: "State",
            url: "https://dev.azure.com/fabrikam/_apis/wit/fields/System.State",
          },
          width: 100,
        },            
        {
          columnFieldReference: {
            referenceName: "System.Tags",
            name: "Tags",
            url: "https://dev.azure.com/fabrikam/_apis/wit/fields/System.Tags",
          },
          width: 200,
        },
      ],
      workItemTypes: [
        {
          name: "Feature",
          url: "https://dev.azure.com/fabrikam/Fabrikam-Fiber/_apis/wit/workItemTypes/Feature",
        },
      ],
      defaultWorkItemType: {
        name: "Feature",
        url: "https://dev.azure.com/fabrikam/Fabrikam-Fiber/_apis/wit/workItemTypes/Feature",
      },
      color: "773B93",
      isHidden: false,
      type: "portfolio",
    },    
  ],
};

export const _mockWorkItem = {
  id: 131489,
  rev: 1,
  fields: {
    "System.AreaPath": "CustomProcessPrj",
    "System.TeamProject": "CustomProcessPrj",
    "System.IterationPath": "CustomProcessPrj",
    "System.WorkItemType": "Task",
    "System.State": "New",
    "System.Reason": "New",
    "System.CreatedDate": "2017-10-06T01:04:51.57Z",
    "System.CreatedBy": {
      displayName: "Jamal Hartnett",
      url: "https://vssps.dev.azure.com/fabrikam/_apis/Identities/d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
      _links: {
        avatar: {
          href: "https://dev.azure.com/mseng/_apis/GraphProfile/MemberAvatars/aad.YTkzODFkODYtNTYxYS03ZDdiLWJjM2QtZDUzMjllMjM5OTAz",
        },
      },
      id: "d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
      uniqueName: "fabrikamfiber4@hotmail.com",
      imageUrl:
        "https://dev.azure.com/fabrikam/_api/_common/identityImage?id=d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
      descriptor: "aad.YTkzODFkODYtNTYxYS03ZDdiLWJjM2QtZDUzMjllMjM5OTAz",
    },
    "System.ChangedDate": "2017-10-06T01:04:51.57Z",
    "System.ChangedBy": {
      displayName: "Jamal Hartnett",
      url: "https://vssps.dev.azure.com/fabrikam/_apis/Identities/d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
      _links: {
        avatar: {
          href: "https://dev.azure.com/mseng/_apis/GraphProfile/MemberAvatars/aad.YTkzODFkODYtNTYxYS03ZDdiLWJjM2QtZDUzMjllMjM5OTAz",
        },
      },
      id: "d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
      uniqueName: "fabrikamfiber4@hotmail.com",
      imageUrl:
        "https://dev.azure.com/fabrikam/_api/_common/identityImage?id=d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
      descriptor: "aad.YTkzODFkODYtNTYxYS03ZDdiLWJjM2QtZDUzMjllMjM5OTAz",
    },
    "System.Title": "Sample task",
    "Microsoft.VSTS.Common.StateChangeDate": "2017-10-06T01:04:51.57Z",
    "Microsoft.VSTS.Common.Priority": 2,
  },
  _links: {
    self: {
      href: "https://dev.azure.com/fabrikam/_apis/wit/workItems/131489",
    },
    workItemUpdates: {
      href: "https://dev.azure.com/fabrikam/_apis/wit/workItems/131489/updates",
    },
    workItemRevisions: {
      href: "https://dev.azure.com/fabrikam/_apis/wit/workItems/131489/revisions",
    },
    workItemHistory: {
      href: "https://dev.azure.com/fabrikam/_apis/wit/workItems/131489/history",
    },
    html: {
      href: "https://dev.azure.com/fabrikam/web/wi.aspx?pcguid=20cda608-32f0-4e6e-9b7c-8def7b38d15a&id=131489",
    },
    workItemType: {
      href: "https://dev.azure.com/fabrikam/aaee31d9-14cf-48b9-a92b-3f1446c13f80/_apis/wit/workItemTypes/Task",
    },
    fields: {
      href: "https://dev.azure.com/fabrikam/_apis/wit/fields",
    },
  },
  url: "https://dev.azure.com/fabrikam/_apis/wit/workItems/131489",
};

export const _mockWorkItemComment = {
  workItemId: 299,
  commentId: 50,
  version: 1,
  text: "Moving to the right area path",
  createdBy: {
    displayName: "Jamal Hartnett",
    url: "https://vssps.dev.azure.com/fabrikam/_apis/Identities/d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
    _links: {
      avatar: {
        href: "https://dev.azure.com/mseng/_apis/GraphProfile/MemberAvatars/aad.YTkzODFkODYtNTYxYS03ZDdiLWJjM2QtZDUzMjllMjM5OTAz",
      },
    },
    id: "d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
    uniqueName: "fabrikamfiber4@hotmail.com",
    imageUrl:
      "https://dev.azure.com/fabrikam/_api/_common/identityImage?id=d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
    descriptor: "aad.YTkzODFkODYtNTYxYS03ZDdiLWJjM2QtZDUzMjllMjM5OTAz",
  },
  createdDate: "2019-01-16T03:03:28.97Z",
  modifiedBy: {
    displayName: "Jamal Hartnett",
    url: "https://vssps.dev.azure.com/fabrikam/_apis/Identities/d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
    _links: {
      avatar: {
        href: "https://dev.azure.com/mseng/_apis/GraphProfile/MemberAvatars/aad.YTkzODFkODYtNTYxYS03ZDdiLWJjM2QtZDUzMjllMjM5OTAz",
      },
    },
    id: "d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
    uniqueName: "fabrikamfiber4@hotmail.com",
    imageUrl:
      "https://dev.azure.com/fabrikam/_api/_common/identityImage?id=d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
    descriptor: "aad.YTkzODFkODYtNTYxYS03ZDdiLWJjM2QtZDUzMjllMjM5OTAz",
  },
  modifiedDate: "2019-01-16T03:03:28.97Z",
  isDeleted: false,
  url: "https://dev.azure.com/fabrikam/6ce954b1-ce1f-45d1-b94d-e6bf2464ba2c/_apis/wit/workItems/299/comments/50",
};

export const _mockWorkItemComments = {
  totalCount: 10,
  count: 2,
  comments: [
    {
      workItemId: 299,
      commentId: 45,
      version: 1,
      text: "Johnnie is going to take this work over.",
      createdBy: {
        displayName: "Jamal Hartnett",
        url: "https://vssps.dev.azure.com/fabrikam/_apis/Identities/d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
        _links: {
          avatar: {
            href: "https://dev.azure.com/mseng/_apis/GraphProfile/MemberAvatars/aad.YTkzODFkODYtNTYxYS03ZDdiLWJjM2QtZDUzMjllMjM5OTAz",
          },
        },
        id: "d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
        uniqueName: "fabrikamfiber4@hotmail.com",
        imageUrl:
          "https://dev.azure.com/fabrikam/_api/_common/identityImage?id=d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
        descriptor: "aad.YTkzODFkODYtNTYxYS03ZDdiLWJjM2QtZDUzMjllMjM5OTAz",
      },
      createdDate: "2019-01-21T20:12:14.683Z",
      modifiedBy: {
        displayName: "Jamal Hartnett",
        url: "https://vssps.dev.azure.com/fabrikam/_apis/Identities/d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
        _links: {
          avatar: {
            href: "https://dev.azure.com/mseng/_apis/GraphProfile/MemberAvatars/aad.YTkzODFkODYtNTYxYS03ZDdiLWJjM2QtZDUzMjllMjM5OTAz",
          },
        },
        id: "d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
        uniqueName: "fabrikamfiber4@hotmail.com",
        imageUrl:
          "https://dev.azure.com/fabrikam/_api/_common/identityImage?id=d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
        descriptor: "aad.YTkzODFkODYtNTYxYS03ZDdiLWJjM2QtZDUzMjllMjM5OTAz",
      },
      modifiedDate: "2019-01-21T20:12:14.683Z",
      isDeleted: false,
      url: "https://dev.azure.com/fabrikam/6ce954b1-ce1f-45d1-b94d-e6bf2464ba2c/_apis/wit/workItems/299/comments/45",
    },
    {
      workItemId: 299,
      commentId: 44,
      version: 1,
      text: "Moving to the right area path",
      createdBy: {
        displayName: "Jamal Hartnett",
        url: "https://vssps.dev.azure.com/fabrikam/_apis/Identities/d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
        _links: {
          avatar: {
            href: "https://dev.azure.com/mseng/_apis/GraphProfile/MemberAvatars/aad.YTkzODFkODYtNTYxYS03ZDdiLWJjM2QtZDUzMjllMjM5OTAz",
          },
        },
        id: "d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
        uniqueName: "fabrikamfiber4@hotmail.com",
        imageUrl:
          "https://dev.azure.com/fabrikam/_api/_common/identityImage?id=d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
        descriptor: "aad.YTkzODFkODYtNTYxYS03ZDdiLWJjM2QtZDUzMjllMjM5OTAz",
      },
      createdDate: "2019-01-20T23:26:33.383Z",
      modifiedBy: {
        displayName: "Jamal Hartnett",
        url: "https://vssps.dev.azure.com/fabrikam/_apis/Identities/d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
        _links: {
          avatar: {
            href: "https://dev.azure.com/mseng/_apis/GraphProfile/MemberAvatars/aad.YTkzODFkODYtNTYxYS03ZDdiLWJjM2QtZDUzMjllMjM5OTAz",
          },
        },
        id: "d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
        uniqueName: "fabrikamfiber4@hotmail.com",
        imageUrl:
          "https://dev.azure.com/fabrikam/_api/_common/identityImage?id=d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
        descriptor: "aad.YTkzODFkODYtNTYxYS03ZDdiLWJjM2QtZDUzMjllMjM5OTAz",
      },
      modifiedDate: "2019-01-20T23:26:33.383Z",
      isDeleted: false,
      url: "https://dev.azure.com/fabrikam/6ce954b1-ce1f-45d1-b94d-e6bf2464ba2c/_apis/wit/workItems/299/comments/44",
    },
  ],
  nextPage:
    "https://dev.azure.com/fabrikam/6ce954b1-ce1f-45d1-b94d-e6bf2464ba2c/_apis/wit/workItems/299/comments?continuationToken=DFkODYtNTYxYS03ZDdiLWJj&api-version=5.1-preview",
  continuationToken: "DFkODYtNTYxYS03ZDdiLWJj",
};

export const _mockWorkItemsForIteration = {
  workItemRelations: [
    {
      rel: null,
      source: null,
      target: {
        id: 1,
        url: "https://dev.azure.com/fabrikam/_apis/wit/workItems/1",
      },
    },
    {
      rel: "System.LinkTypes.Hierarchy-Forward",
      source: {
        id: 1,
        url: "https://dev.azure.com/fabrikam/_apis/wit/workItems/1",
      },
      target: {
        id: 3,
        url: "https://dev.azure.com/fabrikam/_apis/wit/workItems/3",
      },
    },
  ],
  url: "https://dev.azure.com/fabrikam/Fabrikam-Fiber/_apis/work/teamsettings/iterations/a589a806-bf11-4d4f-a031-c19813331553/workitems",
  _links: {
    self: {
      href: "https://dev.azure.com/fabrikam/Fabrikam-Fiber/_apis/work/teamsettings/iterations/a589a806-bf11-4d4f-a031-c19813331553/workitems",
    },
    iteration: {
      href: "https://dev.azure.com/fabrikam/Fabrikam-Fiber/_apis/work/teamsettings/iterations/a589a806-bf11-4d4f-a031-c19813331553",
    },
  },
};

export const _mockWorkItemType = {
  name: "Bug",
  referenceName: "Microsoft.VSTS.WorkItemTypes.Bug",
  description:
    "Describes a divergence between required and actual behavior, and tracks the work done to correct the defect and verify the correction.",
  color: "CC293D",
  icon: {
    id: "icon_insect",
    url: "https://dev.azure.com/fabrikam/_apis/wit/workItemIcons/icon_insect?color=CC293D&v=2",
  },
  isDisabled: false,
  fields: [
    {
      helpText: "The iteration within which this bug will be fixed",
      alwaysRequired: false,
      referenceName: "System.IterationPath",
      name: "Iteration Path",
      url: "https://dev.azure.com/fabrikam/_apis/wit/fields",
    },
    {
      alwaysRequired: true,
      referenceName: "System.IterationId",
      name: "Iteration ID",
      url: "https://dev.azure.com/fabrikam/_apis/wit/fields",
    },
    {
      alwaysRequired: false,
      referenceName: "System.ExternalLinkCount",
      name: "External Link Count",
      url: "https://dev.azure.com/fabrikam/_apis/wit/fields",
    },
    {
      alwaysRequired: false,
      referenceName: "System.TeamProject",
      name: "Team Project",
      url: "https://dev.azure.com/fabrikam/_apis/wit/fields",
    },
  ],
};

export const _mockQuery = {
  id: "342f0f44-4069-46b1-a940-3d0468979ceb",
  name: "Active Bugs",
  path: "My Queries/Website/Active Bugs",
  createdBy: {
    displayName: "Jamal Hartnett",
    url: "https://vssps.dev.azure.com/fabrikam/_apis/Identities/d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
    _links: {
      avatar: {
        href: "https://dev.azure.com/mseng/_apis/GraphProfile/MemberAvatars/aad.YTkzODFkODYtNTYxYS03ZDdiLWJjM2QtZDUzMjllMjM5OTAz",
      },
    },
    id: "d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
    uniqueName: "fabrikamfiber4@hotmail.com",
    imageUrl:
      "https://dev.azure.com/fabrikam/_api/_common/identityImage?id=d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
    descriptor: "aad.YTkzODFkODYtNTYxYS03ZDdiLWJjM2QtZDUzMjllMjM5OTAz",
  },
  createdDate: "2014-03-18T17:18:36.06Z",
  lastModifiedBy: {
    displayName: "Jamal Hartnett",
    url: "https://vssps.dev.azure.com/fabrikam/_apis/Identities/d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
    _links: {
      avatar: {
        href: "https://dev.azure.com/mseng/_apis/GraphProfile/MemberAvatars/aad.YTkzODFkODYtNTYxYS03ZDdiLWJjM2QtZDUzMjllMjM5OTAz",
      },
    },
    id: "d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
    uniqueName: "fabrikamfiber4@hotmail.com",
    imageUrl:
      "https://dev.azure.com/fabrikam/_api/_common/identityImage?id=d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
    descriptor: "aad.YTkzODFkODYtNTYxYS03ZDdiLWJjM2QtZDUzMjllMjM5OTAz",
  },
  lastModifiedDate: "2014-03-18T17:18:36.06Z",
  lastExecutedBy: {
    displayName: "Jamal Hartnett",
    url: "https://vssps.dev.azure.com/fabrikam/_apis/Identities/d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
    _links: {
      avatar: {
        href: "https://dev.azure.com/mseng/_apis/GraphProfile/MemberAvatars/aad.YTkzODFkODYtNTYxYS03ZDdiLWJjM2QtZDUzMjllMjM5OTAz",
      },
    },
    id: "d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
    uniqueName: "fabrikamfiber4@hotmail.com",
    imageUrl:
      "https://dev.azure.com/fabrikam/_api/_common/identityImage?id=d291b0c4-a05c-4ea6-8df1-4b41d5f39eff",
    descriptor: "aad.YTkzODFkODYtNTYxYS03ZDdiLWJjM2QtZDUzMjllMjM5OTAz",
  },
  lastExecutedDate: "2014-03-18T17:19:36.06Z",
  isDeleted: true,
  isPublic: false,
  _links: {
    self: {
      href: "https://dev.azure.com/fabrikam/6ce954b1-ce1f-45d1-b94d-e6bf2464ba2c/_apis/wit/queries/342f0f44-4069-46b1-a940-3d0468979ceb",
    },
    html: {
      href: "https://dev.azure.com/fabrikam/web/qr.aspx?pguid=6ce954b1-ce1f-45d1-b94d-e6bf2464ba2c&qid=342f0f44-4069-46b1-a940-3d0468979ceb",
    },
    parent: {
      href: "https://dev.azure.com/fabrikam/6ce954b1-ce1f-45d1-b94d-e6bf2464ba2c/_apis/wit/queries/8a8c8212-15ca-41ed-97aa-1d6fbfbcd581",
    },
    wiql: {
      href: "https://dev.azure.com/fabrikam/6ce954b1-ce1f-45d1-b94d-e6bf2464ba2c/_apis/wit/wiql/342f0f44-4069-46b1-a940-3d0468979ceb",
    },
  },
  url: "https://dev.azure.com/fabrikam/6ce954b1-ce1f-45d1-b94d-e6bf2464ba2c/_apis/wit/queries/342f0f44-4069-46b1-a940-3d0468979ceb",
};

export const _mockQueryResults = {
  queryType: "tree",
  asOf: "2014-12-29T20:49:33.803Z",
  columns: [
    {
      referenceName: "System.Id",
      name: "ID",
      url: "https://dev.azure.com/fabrikam/_apis/wit/fields/System.Id",
    },
    {
      referenceName: "System.WorkItemType",
      name: "Work Item Type",
      url: "https://dev.azure.com/fabrikam/_apis/wit/fields/System.WorkItemType",
    },
    {
      referenceName: "System.Title",
      name: "Title",
      url: "https://dev.azure.com/fabrikam/_apis/wit/fields/System.Title",
    },
    {
      referenceName: "System.AssignedTo",
      name: "Assigned To",
      url: "https://dev.azure.com/fabrikam/_apis/wit/fields/System.AssignedTo",
    },
    {
      referenceName: "System.State",
      name: "State",
      url: "https://dev.azure.com/fabrikam/_apis/wit/fields/System.State",
    },
  ],
  workItemRelations: [
    {
      target: {
        id: 4,
        url: "https://dev.azure.com/fabrikam/_apis/wit/workItems/4",
      },
    },
    {
      target: {
        id: 5,
        url: "https://dev.azure.com/fabrikam/_apis/wit/workItems/5",
      },
    },
    {
      target: {
        id: 6,
        url: "https://dev.azure.com/fabrikam/_apis/wit/workItems/6",
      },
    },
    {
      target: {
        id: 7,
        url: "https://dev.azure.com/fabrikam/_apis/wit/workItems/7",
      },
    },
    {
      rel: "System.LinkTypes.Hierarchy-Forward",
      source: {
        id: 7,
        url: "https://dev.azure.com/fabrikam/_apis/wit/workItems/7",
      },
      target: {
        id: 8,
        url: "https://dev.azure.com/fabrikam/_apis/wit/workItems/8",
      },
    },
    {
      rel: "System.LinkTypes.Hierarchy-Forward",
      source: {
        id: 7,
        url: "https://dev.azure.com/fabrikam/_apis/wit/workItems/7",
      },
      target: {
        id: 9,
        url: "https://dev.azure.com/fabrikam/_apis/wit/workItems/9",
      },
    },
    {
      target: {
        id: 20,
        url: "https://dev.azure.com/fabrikam/_apis/wit/workItems/20",
      },
    },
    {
      rel: "System.LinkTypes.Hierarchy-Forward",
      source: {
        id: 20,
        url: "https://dev.azure.com/fabrikam/_apis/wit/workItems/20",
      },
      target: {
        id: 1,
        url: "https://dev.azure.com/fabrikam/_apis/wit/workItems/1",
      },
    },
  ],
};


================================================
FILE: test/src/tools/core.test.ts
================================================
import { AccessToken } from "@azure/identity";
import { describe, expect, it } from "@jest/globals";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { configureCoreTools } from "../../../src/tools/core";
import { WebApi } from "azure-devops-node-api";

type TokenProviderMock = () => Promise<AccessToken>;
type ConnectionProviderMock = () => Promise<WebApi>;

interface CoreApiMock {
  getTeams: jest.Mock;
  getProjects: jest.Mock;
}

describe("configureCoreTools", () => {
  let server: McpServer;
  let tokenProvider: TokenProviderMock;
  let connectionProvider: ConnectionProviderMock;
  let mockConnection: { getCoreApi: jest.Mock; };
  let mockCoreApi: CoreApiMock;  

  beforeEach(() => {
    server = { tool: jest.fn() } as unknown as McpServer;
    tokenProvider = jest.fn();

    mockCoreApi = {
      getProjects: jest.fn(),
      getTeams: jest.fn(),
    };  

    mockConnection = {
      getCoreApi: jest.fn().mockResolvedValue(mockCoreApi)    
    };

    connectionProvider = jest.fn().mockResolvedValue(mockConnection);
  });

  describe("tool registration", () => {
    it("registers core tools on the server", () => {
      configureCoreTools(server, tokenProvider, connectionProvider);
      expect(server.tool as jest.Mock).toHaveBeenCalled();
    });
  });

  describe("list_projects tool", () => {
    it("should call getProjects API with the correct parameters and return the expected result", async () => {
      configureCoreTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "core_list_projects"
      );

      if (!call) throw new Error("core_list_projects tool not registered");
      const [, , , handler] = call;

      (mockCoreApi.getProjects as jest.Mock).mockResolvedValue([
        {
          id: "eb6e4656-77fc-42a1-9181-4c6d8e9da5d1",
          name: "Fabrikam-Fiber-TFVC",
          description: "Team Foundation Version Control projects.",
          url: "https://dev.azure.com/fabrikam/_apis/projects/eb6e4656-77fc-42a1-9181-4c6d8e9da5d1",
          state: "wellFormed",
        },
        {
          id: "6ce954b1-ce1f-45d1-b94d-e6bf2464ba2c",
          name: "Fabrikam-Fiber-Git",
          description: "Git projects",
          url: "https://dev.azure.com/fabrikam/_apis/projects/6ce954b1-ce1f-45d1-b94d-e6bf2464ba2c",
          state: "wellFormed",
        },
        {
          id: "281f9a5b-af0d-49b4-a1df-fe6f5e5f84d0",
          name: "TestGit",
          url: "https://dev.azure.com/fabrikam/_apis/projects/281f9a5b-af0d-49b4-a1df-fe6f5e5f84d0",
          state: "wellFormed",
        },
      ]);

      const params = {
        stateFilter: "wellFormed",
        top: undefined,
        skip: undefined,
        continuationToken: undefined,
        getDefaultTeamImageUrl: undefined,
      };

      const result = await handler(params);

      expect(mockCoreApi.getProjects).toHaveBeenCalledWith(
        "wellFormed",
        undefined,
        undefined,
        undefined,
        false
      );

      expect(result.content[0].text).toBe(
        JSON.stringify(
          [
            {
              id: "eb6e4656-77fc-42a1-9181-4c6d8e9da5d1",
              name: "Fabrikam-Fiber-TFVC",
              description: "Team Foundation Version Control projects.",
              url: "https://dev.azure.com/fabrikam/_apis/projects/eb6e4656-77fc-42a1-9181-4c6d8e9da5d1",
              state: "wellFormed",
            },
            {
              id: "6ce954b1-ce1f-45d1-b94d-e6bf2464ba2c",
              name: "Fabrikam-Fiber-Git",
              description: "Git projects",
              url: "https://dev.azure.com/fabrikam/_apis/projects/6ce954b1-ce1f-45d1-b94d-e6bf2464ba2c",
              state: "wellFormed",
            },
            {
              id: "281f9a5b-af0d-49b4-a1df-fe6f5e5f84d0",
              name: "TestGit",
              url: "https://dev.azure.com/fabrikam/_apis/projects/281f9a5b-af0d-49b4-a1df-fe6f5e5f84d0",
              state: "wellFormed",
            },
          ],
          null,
          2
        )
      );
    });

    it("should handle API errors correctly", async () => {
      configureCoreTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "core_list_projects"
      );

      if (!call) throw new Error("core_list_projects tool not registered");
      const [, , , handler] = call;

      const testError = new Error("API connection failed");
      (mockCoreApi.getProjects as jest.Mock).mockRejectedValue(testError);

      const params = {
        stateFilter: "wellFormed",
        top: undefined,
        skip: undefined,
        continuationToken: undefined
      };

      const result = await handler(params);

      expect(mockCoreApi.getProjects).toHaveBeenCalled();
      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain("Error fetching projects: API connection failed");
    });

    it("should handle null API results correctly", async () => {
      configureCoreTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "core_list_projects"
      );

      if (!call) throw new Error("core_list_projects tool not registered");
      const [, , , handler] = call;

      (mockCoreApi.getProjects as jest.Mock).mockResolvedValue(null);

      const params = {
        stateFilter: "wellFormed",
        top: undefined,
        skip: undefined,
        continuationToken: undefined
      };

      const result = await handler(params);

      expect(mockCoreApi.getProjects).toHaveBeenCalled();
      expect(result.isError).toBe(true);
      expect(result.content[0].text).toBe("No projects found");
    });
  });

  describe("list_project_teams tool", () => {
    it("should call getTeams API with the correct parameters and return the expected result", async () => {
      configureCoreTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "core_list_project_teams"
      );

      if (!call) throw new Error("core_list_project_teams tool not registered");
      const [, , , handler] = call;

      (mockCoreApi.getTeams as jest.Mock).mockResolvedValue([
        {
          id: "564e8204-a90b-4432-883b-d4363c6125ca",
          name: "Quality assurance",
          url: "https://dev.azure.com/fabrikam/_apis/projects/eb6e4656-77fc-42a1-9181-4c6d8e9da5d1/teams/564e8204-a90b-4432-883b-d4363c6125ca",
          description: "Testing staff",
          identityUrl:
            "https://vssps.dev.azure.com/fabrikam/_apis/Identities/564e8204-a90b-4432-883b-d4363c6125ca",
        },
        {
          id: "66df9be7-3586-467b-9c5f-425b29afedfd",
          name: "Fabrikam-Fiber-TFVC Team",
          url: "https://dev.azure.com/fabrikam/_apis/projects/eb6e4656-77fc-42a1-9181-4c6d8e9da5d1/teams/66df9be7-3586-467b-9c5f-425b29afedfd",
          description: "The default project team.",
          identityUrl:
            "https://vssps.dev.azure.com/fabrikam/_apis/Identities/66df9be7-3586-467b-9c5f-425b29afedfd",
        },
      ]);

      const params = {
        project: "eb6e4656-77fc-42a1-9181-4c6d8e9da5d1",
        mine: undefined,
        top: undefined,
        skip: undefined,
        expandIdentity: undefined,
      };

      const result = await handler(params);

      expect(mockCoreApi.getTeams).toHaveBeenCalledWith(
        "eb6e4656-77fc-42a1-9181-4c6d8e9da5d1",
        undefined,
        undefined,
        undefined,
        false
      );

      expect(result.content[0].text).toBe(
        JSON.stringify(
          [
            {
              id: "564e8204-a90b-4432-883b-d4363c6125ca",
              name: "Quality assurance",
              url: "https://dev.azure.com/fabrikam/_apis/projects/eb6e4656-77fc-42a1-9181-4c6d8e9da5d1/teams/564e8204-a90b-4432-883b-d4363c6125ca",
              description: "Testing staff",
              identityUrl:
                "https://vssps.dev.azure.com/fabrikam/_apis/Identities/564e8204-a90b-4432-883b-d4363c6125ca",
            },
            {
              id: "66df9be7-3586-467b-9c5f-425b29afedfd",
              name: "Fabrikam-Fiber-TFVC Team",
              url: "https://dev.azure.com/fabrikam/_apis/projects/eb6e4656-77fc-42a1-9181-4c6d8e9da5d1/teams/66df9be7-3586-467b-9c5f-425b29afedfd",
              description: "The default project team.",
              identityUrl:
                "https://vssps.dev.azure.com/fabrikam/_apis/Identities/66df9be7-3586-467b-9c5f-425b29afedfd",
            },
          ],
          null,
          2
        )
      );
    });

    it("should handle API errors correctly", async () => {
      configureCoreTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "core_list_project_teams"
      );

      if (!call) throw new Error("core_list_project_teams tool not registered");
      const [, , , handler] = call;

      const testError = new Error("Team not found");
      (mockCoreApi.getTeams as jest.Mock).mockRejectedValue(testError);

      const params = {
        project: "eb6e4656-77fc-42a1-9181-4c6d8e9da5d1",
        mine: undefined,
        top: undefined,
        skip: undefined
      };

      const result = await handler(params);

      expect(mockCoreApi.getTeams).toHaveBeenCalled();
      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain("Error fetching project teams: Team not found");
    });

    it("should handle null API results correctly", async () => {
      configureCoreTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "core_list_project_teams"
      );
      
      if (!call) throw new Error("core_list_project_teams tool not registered");
      const [, , , handler] = call;

      (mockCoreApi.getTeams as jest.Mock).mockResolvedValue(null);

      const params = {
        project: "eb6e4656-77fc-42a1-9181-4c6d8e9da5d1",
        mine: undefined,
        top: undefined,
        skip: undefined
      };

      const result = await handler(params);

      expect(mockCoreApi.getTeams).toHaveBeenCalled();
      expect(result.isError).toBe(true);
      expect(result.content[0].text).toBe("No teams found");
    });
  });
});



================================================
FILE: test/src/tools/testplan.test.ts
================================================
import { AccessToken } from "@azure/identity";
import { describe, expect, it } from '@jest/globals';
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { WebApi } from "azure-devops-node-api";
import { configureTestPlanTools } from '../../../src/tools/testplans';
import { ITestPlanApi } from "azure-devops-node-api/TestPlanApi";
import { ITestResultsApi } from "azure-devops-node-api/TestResultsApi";

type TokenProviderMock = () => Promise<AccessToken>;
type ConnectionProviderMock = () => Promise<WebApi>;

describe("configureTestPlanTools", () => {
  let server: McpServer;
  let tokenProvider: TokenProviderMock;
  let connectionProvider: ConnectionProviderMock;
   let mockConnection: {
    getTestPlanApi: () => Promise<ITestPlanApi>;
    getTestResultsApi: () => Promise<ITestResultsApi>;
  };
  let mockTestPlanApi: ITestPlanApi;
  let mockTestResultsApi: ITestResultsApi;

  beforeEach(() => {
    server = { tool: jest.fn() } as unknown as McpServer;
    tokenProvider = jest.fn();
    mockTestPlanApi = {
      getTestPlans: jest.fn(),
      createTestPlan: jest.fn(),
      addTestCasesToSuite: jest.fn(),
      getTestCaseList: jest.fn(),
    } as unknown as ITestPlanApi;
    mockTestResultsApi = {
      getTestResultDetailsForBuild: jest.fn(),
    } as unknown as ITestResultsApi;
    mockConnection = {
      getTestPlanApi: jest.fn().mockResolvedValue(mockTestPlanApi),
      getTestResultsApi: jest.fn().mockResolvedValue(mockTestResultsApi),
    };
    connectionProvider = jest.fn().mockResolvedValue(mockConnection);
  });

  describe("tool registration", () => {
    it("registers test plan tools on the server", () => {
      configureTestPlanTools(server, tokenProvider, connectionProvider);
      expect((server.tool as jest.Mock).mock.calls.map(call => call[0])).toEqual(
        expect.arrayContaining([
          "testplan_list_test_plans",
          "testplan_create_test_plan",
          "testplan_add_test_cases_to_suite",
          "testplan_list_test_cases",
          "testplan_show_test_results_from_build_id",
        ])
      );
    });
  });

  describe("list_test_plans tool", () => {
    it("should call getTestPlans with the correct parameters and return the expected result", async () => {
      configureTestPlanTools(server, tokenProvider, connectionProvider);
      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "testplan_list_test_plans"
      );
      if (!call) throw new Error("testplan_list_test_plans tool not registered");
      const [, , , handler] = call;

      (mockTestPlanApi.getTestPlans as jest.Mock).mockResolvedValue([{ id: 1, name: "Test Plan 1" }]);
      const params = {
        project: "proj1",
        filterActivePlans: true,
        includePlanDetails: false,
        continuationToken: undefined,
      };
      const result = await handler(params);

      expect(mockTestPlanApi.getTestPlans).toHaveBeenCalledWith(
        "proj1",
        "",
        undefined,
        false,
        true
      );
      expect(result.content[0].text).toBe(JSON.stringify([{ id: 1, name: "Test Plan 1" }], null, 2));
    });
  });

  describe("create_test_plan tool", () => {
    it("should call createTestPlan with the correct parameters and return the expected result", async () => {
      configureTestPlanTools(server, tokenProvider, connectionProvider);
      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "testplan_create_test_plan"
      );
      if (!call) throw new Error("testplan_create_test_plan tool not registered");
      const [, , , handler] = call;

      (mockTestPlanApi.createTestPlan as jest.Mock).mockResolvedValue({ id: 1, name: "New Test Plan" });
      const params = {
        project: "proj1",
        name: "New Test Plan",
        iteration: "Iteration 1",
        description: "Description",
        startDate: "2025-05-01",
        endDate: "2025-05-31",
        areaPath: "Area 1",
      };
      const result = await handler(params);

      expect(mockTestPlanApi.createTestPlan).toHaveBeenCalledWith(
        {
          name: "New Test Plan",
          iteration: "Iteration 1",
          description: "Description",
          startDate: new Date("2025-05-01"),
          endDate: new Date("2025-05-31"),
          areaPath: "Area 1",
        },
        "proj1"
      );
      expect(result.content[0].text).toBe(JSON.stringify({ id: 1, name: "New Test Plan" }, null, 2));
    });
  });

  describe("list_test_cases tool", () => {
    it("should call getTestCaseList with the correct parameters and return the expected result", async () => {
      configureTestPlanTools(server, tokenProvider, connectionProvider);
      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "testplan_list_test_cases"
      );
      if (!call) throw new Error("testplan_list_test_cases tool not registered");
      const [, , , handler] = call;

      (mockTestPlanApi.getTestCaseList as jest.Mock).mockResolvedValue([{ id: 1, name: "Test Case 1" }]);
      const params = {
        project: "proj1",
        planid: 1,
        suiteid: 2,
      };
      const result = await handler(params);

      expect(mockTestPlanApi.getTestCaseList).toHaveBeenCalledWith(
        "proj1",
        1,
        2
      );
      expect(result.content[0].text).toBe(JSON.stringify([{ id: 1, name: "Test Case 1" }], null, 2));
    });
  });

  describe("test_results_from_build_id tool", () => {
    it("should call getTestResultDetailsForBuild with the correct parameters and return the expected result", async () => {
      configureTestPlanTools(server, tokenProvider, connectionProvider);
      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "testplan_show_test_results_from_build_id"
      );
      if (!call) throw new Error("testplan_show_test_results_from_build_id tool not registered");
      const [, , , handler] = call;

      (mockTestResultsApi.getTestResultDetailsForBuild as jest.Mock).mockResolvedValue({ results: ["Result 1"] });
      const params = {
        project: "proj1",
        buildid: 123,
      };
      const result = await handler(params);

      expect(mockTestResultsApi.getTestResultDetailsForBuild).toHaveBeenCalledWith(
        "proj1",
        123
      );
      expect(result.content[0].text).toBe(JSON.stringify({ results: ["Result 1"] }, null, 2));
    });
  });
});


================================================
FILE: test/src/tools/wiki.test.ts
================================================
import { AccessToken } from "@azure/identity";
import { describe, expect, it } from '@jest/globals';
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { WebApi } from "azure-devops-node-api";
import { configureWikiTools } from '../../../src/tools/wiki';

type TokenProviderMock = () => Promise<AccessToken>;
type ConnectionProviderMock = () => Promise<WebApi>;
interface WikiApiMock {
  getWiki: jest.Mock;
  getAllWikis: jest.Mock;
  getPagesBatch: jest.Mock;
  getPageText: jest.Mock;
}

describe("configureWikiTools", () => {
  let server: McpServer;
  let tokenProvider: TokenProviderMock;
  let connectionProvider: ConnectionProviderMock;
  let mockConnection: { getWikiApi: jest.Mock };
  let mockWikiApi: WikiApiMock;

  beforeEach(() => {
    server = { tool: jest.fn() } as unknown as McpServer;
    tokenProvider = jest.fn();
    mockWikiApi = {
      getWiki: jest.fn(),
      getAllWikis: jest.fn(),
      getPagesBatch: jest.fn(),
      getPageText: jest.fn(),
    };
    mockConnection = {
      getWikiApi: jest.fn().mockResolvedValue(mockWikiApi),
    };
    connectionProvider = jest.fn().mockResolvedValue(mockConnection);
  });

  describe("tool registration", () => {
    it("registers wiki tools on the server", () => {
      configureWikiTools(server, tokenProvider, connectionProvider);
      expect((server.tool as jest.Mock)).toHaveBeenCalled();
    });
  });

  describe("get_wiki tool", () => {
    it("should call getWiki with the correct parameters and return the expected result", async () => {
      configureWikiTools(server, tokenProvider, connectionProvider);
      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wiki_get_wiki"
      );
      if (!call) throw new Error("wiki_get_wiki tool not registered");
      const [, , , handler] = call;

      const mockWiki = { id: "wiki1", name: "Test Wiki" };
      mockWikiApi.getWiki.mockResolvedValue(mockWiki);

      const params = {
        wikiIdentifier: "wiki1",
        project: "proj1"
      };
      
      const result = await handler(params);

      expect(mockWikiApi.getWiki).toHaveBeenCalledWith("wiki1", "proj1");
      expect(result.content[0].text).toBe(JSON.stringify(mockWiki, null, 2));
      expect(result.isError).toBeUndefined();
    });

    it("should handle API errors correctly", async () => {
      configureWikiTools(server, tokenProvider, connectionProvider);
      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wiki_get_wiki"
      );
      if (!call) throw new Error("wiki_get_wiki tool not registered");
      const [, , , handler] = call;

      const testError = new Error("Wiki not found");
      mockWikiApi.getWiki.mockRejectedValue(testError);

      const params = {
        wikiIdentifier: "nonexistent",
        project: "proj1"
      };

      const result = await handler(params);

      expect(mockWikiApi.getWiki).toHaveBeenCalled();
      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain("Error fetching wiki: Wiki not found");
    });

    it("should handle null API results correctly", async () => {
      configureWikiTools(server, tokenProvider, connectionProvider);
      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wiki_get_wiki"
      );
      if (!call) throw new Error("wiki_get_wiki tool not registered");
      const [, , , handler] = call;

      mockWikiApi.getWiki.mockResolvedValue(null);

      const params = {
        wikiIdentifier: "wiki1",
        project: "proj1"
      };

      const result = await handler(params);

      expect(mockWikiApi.getWiki).toHaveBeenCalled();
      expect(result.isError).toBe(true);
      expect(result.content[0].text).toBe("No wiki found");
    });
  });

  describe("list_wikis tool", () => {
    it("should call getAllWikis with the correct parameters and return the expected result", async () => {
      configureWikiTools(server, tokenProvider, connectionProvider);
      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wiki_list_wikis"
      );
      if (!call) throw new Error("wiki_list_wikis tool not registered");
      const [, , , handler] = call;

      const mockWikis = [{ id: "wiki1", name: "Wiki 1" }, { id: "wiki2", name: "Wiki 2" }];
      mockWikiApi.getAllWikis.mockResolvedValue(mockWikis);

      const params = {
        project: "proj1"
      };
      
      const result = await handler(params);

      expect(mockWikiApi.getAllWikis).toHaveBeenCalledWith("proj1");
      expect(result.content[0].text).toBe(JSON.stringify(mockWikis, null, 2));
      expect(result.isError).toBeUndefined();
    });

    it("should handle API errors correctly", async () => {
      configureWikiTools(server, tokenProvider, connectionProvider);
      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wiki_list_wikis"
      );
      if (!call) throw new Error("wiki_list_wikis tool not registered");
      const [, , , handler] = call;

      const testError = new Error("Failed to fetch wikis");
      mockWikiApi.getAllWikis.mockRejectedValue(testError);

      const params = {
        project: "proj1"
      };

      const result = await handler(params);

      expect(mockWikiApi.getAllWikis).toHaveBeenCalled();
      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain("Error fetching wikis: Failed to fetch wikis");
    });

    it("should handle null API results correctly", async () => {
      configureWikiTools(server, tokenProvider, connectionProvider);
      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wiki_list_wikis"
      );
      if (!call) throw new Error("wiki_list_wikis tool not registered");
      const [, , , handler] = call;

      mockWikiApi.getAllWikis.mockResolvedValue(null);

      const params = {
        project: "proj1"
      };

      const result = await handler(params);

      expect(mockWikiApi.getAllWikis).toHaveBeenCalled();
      expect(result.isError).toBe(true);
      expect(result.content[0].text).toBe("No wikis found");
    });
  });

  describe("list_wiki_pages tool", () => {
    it("should call getPagesBatch with the correct parameters and return the expected result", async () => {
      configureWikiTools(server, tokenProvider, connectionProvider);
      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wiki_list_pages"
      );
      if (!call) throw new Error("wiki_list_pages tool not registered");
      const [, , , handler] = call;
      mockWikiApi.getPagesBatch.mockResolvedValue({ value: ["page1", "page2"] });

      const params = {
        wikiIdentifier: "wiki2",
        project: "proj2",
        top: 10,
        continuationToken: "token123",
        pageViewsForDays: 7
      };
      const result = await handler(params);
      const parsedResult = JSON.parse(result.content[0].text);
      
      expect(mockWikiApi.getPagesBatch).toHaveBeenCalledWith(
        {
          top: 10,
          continuationToken: "token123",
          pageViewsForDays: 7
        },
        "proj2",
        "wiki2"
      );
      expect(parsedResult.value).toEqual(["page1", "page2"]);
      expect(result.isError).toBeUndefined();
    });

    it("should handle API errors correctly", async () => {
      configureWikiTools(server, tokenProvider, connectionProvider);
      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wiki_list_pages"
      );
      if (!call) throw new Error("wiki_list_pages tool not registered");
      const [, , , handler] = call;

      const testError = new Error("Failed to fetch wiki pages");
      mockWikiApi.getPagesBatch.mockRejectedValue(testError);

      const params = {
        wikiIdentifier: "wiki1",
        project: "proj1",
        top: 10
      };

      const result = await handler(params);

      expect(mockWikiApi.getPagesBatch).toHaveBeenCalled();
      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain("Error fetching wiki pages: Failed to fetch wiki pages");
    });

    it("should handle null API results correctly", async () => {
      configureWikiTools(server, tokenProvider, connectionProvider);
      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wiki_list_pages"
      );
      if (!call) throw new Error("wiki_list_pages tool not registered");
      const [, , , handler] = call;

      mockWikiApi.getPagesBatch.mockResolvedValue(null);

      const params = {
        wikiIdentifier: "wiki1",
        project: "proj1",
        top: 10
      };

      const result = await handler(params);

      expect(mockWikiApi.getPagesBatch).toHaveBeenCalled();
      expect(result.isError).toBe(true);
      expect(result.content[0].text).toBe("No wiki pages found");
    });
  });

  describe("get_page_content tool", () => {
    it("should call getPageText with the correct parameters and return the expected result", async () => {
      configureWikiTools(server, tokenProvider, connectionProvider);
      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wiki_get_page_content"
      );
      if (!call) throw new Error("wiki_get_page_content tool not registered");
      const [, , , handler] = call;

      // Mock a stream-like object for getPageText
      const mockStream = {
        setEncoding: jest.fn(),
        on: function (event: string, cb: (chunk?: unknown) => void) {
          if (event === "data") {
            setImmediate(() => cb("mock page text"));
          }
          if (event === "end") {
            setImmediate(() => cb());
          }
          return this;
        }
      };
      mockWikiApi.getPageText.mockResolvedValue(mockStream as unknown);

      const params = {
        wikiIdentifier: "wiki1",
        project: "proj1",
        path: "/page1"
      };
      
      const result = await handler(params);

      expect(mockWikiApi.getPageText).toHaveBeenCalledWith(
        "proj1",
        "wiki1",
        "/page1", 
        undefined, 
        undefined, 
        true
      );
      expect(result.content[0].text).toBe("\"mock page text\"");
      expect(result.isError).toBeUndefined();
    });

    it("should handle API errors correctly", async () => {
      configureWikiTools(server, tokenProvider, connectionProvider);
      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wiki_get_page_content"
      );
      if (!call) throw new Error("wiki_get_page_content tool not registered");
      const [, , , handler] = call;

      const testError = new Error("Page not found");
      mockWikiApi.getPageText.mockRejectedValue(testError);

      const params = {
        wikiIdentifier: "wiki1",
        project: "proj1",
        path: "/nonexistent"
      };

      const result = await handler(params);

      expect(mockWikiApi.getPageText).toHaveBeenCalled();
      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain("Error fetching wiki page content: Page not found");
    });

    it("should handle null API results correctly", async () => {
      configureWikiTools(server, tokenProvider, connectionProvider);
      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wiki_get_page_content"
      );
      if (!call) throw new Error("wiki_get_page_content tool not registered");
      const [, , , handler] = call;

      mockWikiApi.getPageText.mockResolvedValue(null);

      const params = {
        wikiIdentifier: "wiki1",
        project: "proj1",
        path: "/page1"
      };

      const result = await handler(params);

      expect(mockWikiApi.getPageText).toHaveBeenCalled();
      expect(result.isError).toBe(true);
      expect(result.content[0].text).toBe("No wiki page content found");
    });

    it("should handle stream errors correctly", async () => {
      configureWikiTools(server, tokenProvider, connectionProvider);
      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wiki_get_page_content"
      );
      if (!call) throw new Error("wiki_get_page_content tool not registered");
      const [, , , handler] = call;

      // Mock a stream that emits an error
      const mockStream = {
        setEncoding: jest.fn(),
        on: function (event: string, cb: (error?: Error) => void) {
          if (event === "error") {
            setImmediate(() => cb(new Error("Stream read error")));
          }
          return this;
        }
      };
      mockWikiApi.getPageText.mockResolvedValue(mockStream as unknown);

      const params = {
        wikiIdentifier: "wiki1",
        project: "proj1",
        path: "/page1"
      };

      const result = await handler(params);

      expect(mockWikiApi.getPageText).toHaveBeenCalled();
      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain("Error fetching wiki page content: Stream read error");
    });
  });
});


================================================
FILE: test/src/tools/work.test.ts
================================================
import { AccessToken } from "@azure/identity";
import { describe, expect, it } from "@jest/globals";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { configureWorkTools } from "../../../src/tools/work";
import { WebApi } from "azure-devops-node-api";
import { TreeStructureGroup } from "azure-devops-node-api/interfaces/WorkItemTrackingInterfaces";

type TokenProviderMock = () => Promise<AccessToken>;
type ConnectionProviderMock = () => Promise<WebApi>;

interface WorkApiMock {
  getTeamIterations: jest.Mock;
  postTeamIteration: jest.Mock;
}

interface WorkItemTrackingApiMock {
  createOrUpdateClassificationNode: jest.Mock;
}

describe("configureWorkTools", () => {
  let server: McpServer;
  let tokenProvider: TokenProviderMock;
  let connectionProvider: ConnectionProviderMock;
  let mockConnection: { getWorkApi: jest.Mock, getWorkItemTrackingApi: jest.Mock };
  let mockWorkApi: WorkApiMock;
  let mockWorkItemTrackingApi: WorkItemTrackingApiMock;

  beforeEach(() => {
    server = { tool: jest.fn() } as unknown as McpServer;
    tokenProvider = jest.fn();  

    mockWorkApi = {
      getTeamIterations: jest.fn(),
      postTeamIteration: jest.fn(),
    };

    mockWorkItemTrackingApi = {
      createOrUpdateClassificationNode: jest.fn(),
    };

    mockConnection = {     
      getWorkApi: jest.fn().mockResolvedValue(mockWorkApi),
      getWorkItemTrackingApi: jest.fn().mockResolvedValue(mockWorkItemTrackingApi),
    };

    connectionProvider = jest.fn().mockResolvedValue(mockConnection);
  });

  describe("tool registration", () => {
    it("registers core tools on the server", () => {
      configureWorkTools(server, tokenProvider, connectionProvider);
      expect(server.tool as jest.Mock).toHaveBeenCalled();
    });
  });

  describe("list_team_iterations tool", () => {
    it("should call getTeamIterations API with the correct parameters and return the expected result", async () => {
      configureWorkTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "work_list_team_iterations"
      );
      if (!call)
        throw new Error("work_list_team_iterations tool not registered");
      const [, , , handler] = call;

      (mockWorkApi.getTeamIterations as jest.Mock).mockResolvedValue([
        {
          id: "a589a806-bf11-4d4f-a031-c19813331553",
          name: "Sprint 2",
          attributes: {
            startDate: null,
            finishDate: null,
          },
          url: "https://dev.azure.com/fabrikam/6d823a47-2d51-4f31-acff-74927f88ee1e/748b18b6-4b3c-425a-bcae-ff9b3e703012/_apis/work/teamsettings/iterations/a589a806-bf11-4d4f-a031-c19813331553",
        },
      ]);

      const params = {
        project: "fabrikam",
        team: undefined,
        timeframe: undefined,
      };

      const result = await handler(params);

      expect(mockWorkApi.getTeamIterations).toHaveBeenCalledWith(
        { project: "fabrikam", team: undefined },
        undefined
      );

      expect(result.content[0].text).toBe(
        JSON.stringify(
          [
            {
              id: "a589a806-bf11-4d4f-a031-c19813331553",
              name: "Sprint 2",
              attributes: {
                startDate: null,
                finishDate: null,
              },
              url: "https://dev.azure.com/fabrikam/6d823a47-2d51-4f31-acff-74927f88ee1e/748b18b6-4b3c-425a-bcae-ff9b3e703012/_apis/work/teamsettings/iterations/a589a806-bf11-4d4f-a031-c19813331553",
            },
          ],
          null,
          2
        )
      );
    });

    it("should handle API errors correctly", async () => {
      configureWorkTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "work_list_team_iterations"
      );
      if (!call)
        throw new Error("work_list_team_iterations tool not registered");
      const [, , , handler] = call;

      const testError = new Error("Failed to retrieve iterations");
      (mockWorkApi.getTeamIterations as jest.Mock).mockRejectedValue(testError);

      const params = {
        project: "fabrikam",
        team: "Fabrikam Team",
        timeframe: undefined,
      };

      const result = await handler(params);

      expect(mockWorkApi.getTeamIterations).toHaveBeenCalled();
      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain("Error fetching team iterations: Failed to retrieve iterations");
    });

    it("should handle null API results correctly", async () => {
      configureWorkTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "work_list_team_iterations"
      );
      if (!call)
        throw new Error("work_list_team_iterations tool not registered");
      const [, , , handler] = call;

      (mockWorkApi.getTeamIterations as jest.Mock).mockResolvedValue(null);

      const params = {
        project: "fabrikam",
        team: "Fabrikam Team",
        timeframe: undefined,
      };

      const result = await handler(params);

      expect(mockWorkApi.getTeamIterations).toHaveBeenCalled();
      expect(result.isError).toBe(true);
      expect(result.content[0].text).toBe("No iterations found");
    });
  });

  describe("assign_iterations", () => {
    it("should call postTeamIteration API with the correct parameters and return the expected result", async () => {
      configureWorkTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "work_assign_iterations"
      );

      if (!call) throw new Error("work_assign_iterations tool not registered");
      const [, , , handler] = call;

      (mockWorkApi.postTeamIteration as jest.Mock).mockResolvedValue({
        id: "a589a806-bf11-4d4f-a031-c19813331553",
        name: "Sprint 2",
        path: "Fabrikam-Fiber\\Release 1\\Sprint 2",
        attributes: {
          startDate: null,
          finishDate: null,
        },
        url: "https://dev.azure.com/fabrikam/6d823a47-2d51-4f31-acff-74927f88ee1e/748b18b6-4b3c-425a-bcae-ff9b3e703012/_apis/work/teamsettings/iterations/a589a806-bf11-4d4f-a031-c19813331553",
      });

      const params = {
        project: "Fabrikam",
        team: "Fabrikam Team",
        iterations: [
          {
            identifier: "a589a806-bf11-4d4f-a031-c19813331553",
            path: "Fabrikam-Fiber\\Release 1\\Sprint 2",
          },
        ],
      };

      const result = await handler(params);

      expect(mockWorkApi.postTeamIteration).toHaveBeenCalledWith(
        {
          id: "a589a806-bf11-4d4f-a031-c19813331553",
          path: "Fabrikam-Fiber\\Release 1\\Sprint 2",
        },
        { 
          project: "Fabrikam", 
          team: "Fabrikam Team" 
        }
      );

      expect(result.content[0].text).toBe(
        JSON.stringify(
          [
            {
              id: "a589a806-bf11-4d4f-a031-c19813331553",
              name: "Sprint 2",
              path: "Fabrikam-Fiber\\Release 1\\Sprint 2",
              attributes: {
                startDate: null,
                finishDate: null,
              },
              url: "https://dev.azure.com/fabrikam/6d823a47-2d51-4f31-acff-74927f88ee1e/748b18b6-4b3c-425a-bcae-ff9b3e703012/_apis/work/teamsettings/iterations/a589a806-bf11-4d4f-a031-c19813331553",
            },
          ],
          null,
          2
        )
      );
    });

    it("should handle API errors correctly", async () => {
      configureWorkTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "work_assign_iterations"
      );

      if (!call) throw new Error("work_assign_iterations tool not registered");
      const [, , , handler] = call;

      const testError = new Error("Failed to assign iteration");
      (mockWorkApi.postTeamIteration as jest.Mock).mockRejectedValue(testError);

      const params = {
        project: "Fabrikam",
        team: "Fabrikam Team",
        iterations: [
          {
            identifier: "a589a806-bf11-4d4f-a031-c19813331553",
            path: "Fabrikam-Fiber\\Release 1\\Sprint 2",
          },
        ],
      };

      const result = await handler(params);

      expect(mockWorkApi.postTeamIteration).toHaveBeenCalled();
      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain("Error assigning iterations: Failed to assign iteration");
    });

    it("should handle null API results correctly", async () => {
      configureWorkTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "work_assign_iterations"
      );

      if (!call) throw new Error("work_assign_iterations tool not registered");
      const [, , , handler] = call;

      (mockWorkApi.postTeamIteration as jest.Mock).mockResolvedValue(null);

      const params = {
        project: "Fabrikam",
        team: "Fabrikam Team",
        iterations: [
          {
            identifier: "a589a806-bf11-4d4f-a031-c19813331553",
            path: "Fabrikam-Fiber\\Release 1\\Sprint 2",
          },
        ],
      };

      const result = await handler(params);

      expect(mockWorkApi.postTeamIteration).toHaveBeenCalled();
      expect(result.isError).toBe(true);
      expect(result.content[0].text).toBe("No iterations were assigned to the team");
    });
  });

 describe("create_iterations", () => {
   it("should call createOrUpdateClassificationNode API with the correct parameters and return the expected result", async () => {
     configureWorkTools(server, tokenProvider, connectionProvider);

     const call = (server.tool as jest.Mock).mock.calls.find(
       ([toolName]) => toolName === "work_create_iterations"
     );

     if (!call) throw new Error("work_create_iterations tool not registered");
     const [, , , handler] = call;

     (mockWorkItemTrackingApi.createOrUpdateClassificationNode as jest.Mock).mockResolvedValue({
       id: 126391,
       identifier: "a5c68379-3258-4d62-971c-71c1c459336e",
       name: "Web",
       structureType: "area",
       hasChildren: false,
       path: "\\fabrikam\\fiber\\tfvc\\area",
       _links: {
         self: {
           href: "https://dev.azure.com/fabrikam/6ce954b1-ce1f-45d1-b94d-e6bf2464ba2c/_apis/wit/classificationNodes/Areas/Web",
         },
         parent: {
           href: "https://dev.azure.com/fabrikam/6ce954b1-ce1f-45d1-b94d-e6bf2464ba2c/_apis/wit/classificationNodes/Areas",
         },
       },
       url: "https://dev.azure.com/fabrikam/6ce954b1-ce1f-45d1-b94d-e6bf2464ba2c/_apis/wit/classificationNodes/Areas/Web",
     });

     const params = {
       project: "Fabrikam",
       iterations: [
         {
           iterationName: "Sprint 2",
           startDate: "2025-06-02T00:00:00Z",
           finishDate: "2025-06-13T00:00:00Z",
         },
       ],
     };

     const result = await handler(params);

     expect(
       mockWorkItemTrackingApi.createOrUpdateClassificationNode
     ).toHaveBeenCalledWith(
       {
         name: "Sprint 2",
         attributes: {
           startDate: new Date("2025-06-02T00:00:00Z"),
           finishDate: new Date("2025-06-13T00:00:00Z"),
         },
       },
       "Fabrikam",
       TreeStructureGroup.Iterations
     );

     expect(result.content[0].text).toBe(
       JSON.stringify(
         [
           {
             id: 126391,
             identifier: "a5c68379-3258-4d62-971c-71c1c459336e",
             name: "Web",
             structureType: "area",
             hasChildren: false,
             path: "\\fabrikam\\fiber\\tfvc\\area",
             _links: {
               self: {
                 href: "https://dev.azure.com/fabrikam/6ce954b1-ce1f-45d1-b94d-e6bf2464ba2c/_apis/wit/classificationNodes/Areas/Web",
               },
               parent: {
                 href: "https://dev.azure.com/fabrikam/6ce954b1-ce1f-45d1-b94d-e6bf2464ba2c/_apis/wit/classificationNodes/Areas",
               },
             },
             url: "https://dev.azure.com/fabrikam/6ce954b1-ce1f-45d1-b94d-e6bf2464ba2c/_apis/wit/classificationNodes/Areas/Web",
           },
         ],
         null,
         2
       )
     );
   });

   it("should handle API errors correctly", async () => {
     configureWorkTools(server, tokenProvider, connectionProvider);

     const call = (server.tool as jest.Mock).mock.calls.find(
       ([toolName]) => toolName === "work_create_iterations"
     );
     
     if (!call) throw new Error("work_create_iterations tool not registered");
     const [, , , handler] = call;

     const testError = new Error("Failed to create iteration");
     (mockWorkItemTrackingApi.createOrUpdateClassificationNode as jest.Mock).mockRejectedValue(testError);

     const params = {
       project: "Fabrikam",
       iterations: [
         {
           iterationName: "Sprint 2",
           startDate: "2025-06-02T00:00:00Z",
           finishDate: "2025-06-13T00:00:00Z",
         },
       ],
     };

     const result = await handler(params);

     expect(mockWorkItemTrackingApi.createOrUpdateClassificationNode).toHaveBeenCalled();
     expect(result.isError).toBe(true);
     expect(result.content[0].text).toContain("Error creating iterations: Failed to create iteration");
   });

   it("should handle null API results correctly", async () => {
     configureWorkTools(server, tokenProvider, connectionProvider);

     const call = (server.tool as jest.Mock).mock.calls.find(
       ([toolName]) => toolName === "work_create_iterations"
     );

     if (!call) throw new Error("work_create_iterations tool not registered");
     const [, , , handler] = call;

     (mockWorkItemTrackingApi.createOrUpdateClassificationNode as jest.Mock).mockResolvedValue(null);

     const params = {
       project: "Fabrikam",
       iterations: [
         {
           iterationName: "Sprint 2",
           startDate: "2025-06-02T00:00:00Z",
           finishDate: "2025-06-13T00:00:00Z",
         },
       ],
     };

     const result = await handler(params);

     expect(mockWorkItemTrackingApi.createOrUpdateClassificationNode).toHaveBeenCalled();
     expect(result.isError).toBe(true);
     expect(result.content[0].text).toBe("No iterations were created");
   });
 });

});



================================================
FILE: test/src/tools/workitems.test.ts
================================================
import { AccessToken } from "@azure/identity";
import { describe, expect, it } from "@jest/globals";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { configureWorkItemTools } from "../../../src/tools/workitems";
import { WebApi } from "azure-devops-node-api";
import { _mockBacklogs, _mockQuery, _mockQueryResults, _mockWorkItem, _mockWorkItemComment, _mockWorkItemComments, _mockWorkItems, _mockWorkItemsForIteration, _mockWorkItemType } from "../../mocks/work-items";

type TokenProviderMock = () => Promise<AccessToken>;
type ConnectionProviderMock = () => Promise<WebApi>;

interface WorkApiMock {
  getBacklogs: jest.Mock;
  getBacklogLevelWorkItems: jest.Mock;
  getPredefinedQueryResults: jest.Mock;
  getTeamIterations: jest.Mock;
  getIterationWorkItems: jest.Mock;
}

interface WorkItemTrackingApiMock {
  getWorkItemsBatch: jest.Mock;
  getWorkItem: jest.Mock;
  getComments: jest.Mock;
  addComment: jest.Mock;
  updateWorkItem: jest.Mock;
  createWorkItem: jest.Mock;
  getWorkItemType: jest.Mock;
  getQuery: jest.Mock;
  queryById: jest.Mock;
}

describe("configureWorkItemTools", () => {
  let server: McpServer;
  let tokenProvider: TokenProviderMock;
  let connectionProvider: ConnectionProviderMock;
  let mockConnection: {
    getWorkApi: jest.Mock;
    getWorkItemTrackingApi: jest.Mock;
  };
  let mockWorkApi: WorkApiMock;
  let mockWorkItemTrackingApi: WorkItemTrackingApiMock;

  beforeEach(() => {
    server = { tool: jest.fn() } as unknown as McpServer;
    tokenProvider = jest.fn();

    mockWorkApi = {
      getBacklogs: jest.fn(),
      getBacklogLevelWorkItems: jest.fn(),
      getPredefinedQueryResults: jest.fn(),
      getTeamIterations: jest.fn(),
      getIterationWorkItems: jest.fn(),
    };

    mockWorkItemTrackingApi = {
      getWorkItemsBatch: jest.fn(),
      getWorkItem: jest.fn(),
      getComments: jest.fn(),
      addComment: jest.fn(),
      updateWorkItem: jest.fn(),
      createWorkItem: jest.fn(),
      getWorkItemType: jest.fn(),
      getQuery: jest.fn(),
      queryById: jest.fn(),
    };

    mockConnection = {
      getWorkApi: jest.fn().mockResolvedValue(mockWorkApi),
      getWorkItemTrackingApi: jest.fn().mockResolvedValue(mockWorkItemTrackingApi),
    };

    connectionProvider = jest.fn().mockResolvedValue(mockConnection);
  });

  describe("tool registration", () => {
    it("registers core tools on the server", () => {
      configureWorkItemTools(server, tokenProvider, connectionProvider);
      expect(server.tool as jest.Mock).toHaveBeenCalled();
    });
  });

  describe("list_backlogs tool", () => {
    it("should call getBacklogs API with the correct parameters and return the expected result", async () => {
      configureWorkItemTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wit_list_backlogs"
      );
      if (!call) throw new Error("wit_list_backlogs tool not registered");
      const [, , , handler] = call;

      (mockWorkApi.getBacklogs as jest.Mock).mockResolvedValue([
        _mockBacklogs,
      ]);

      const params = {
        project: "Contoso",
        team: "Fabrikam",
      };

      const result = await handler(params);

      expect(mockWorkApi.getBacklogs).toHaveBeenCalledWith({
        project: params.project,
        team: params.team,
      });

      expect(result.content[0].text).toBe(
        JSON.stringify(
          [
            _mockBacklogs,
          ],
          null,
          2
        )
      );
    });
  });

  describe("list_backlog_work_items tool", () => {
    it("should call getBacklogLevelWorkItems API with the correct parameters and return the expected result", async () => {
      configureWorkItemTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wit_list_backlog_work_items"
      );
      if (!call)
        throw new Error("wit_list_backlog_work_items tool not registered");
      const [, , , handler] = call;

      (mockWorkApi.getBacklogLevelWorkItems as jest.Mock).mockResolvedValue([
        {
          workItems: [
            {
              rel: null,
              source: null,
              target: {
                id: 50,
              },
            },
            {
              rel: null,
              source: null,
              target: {
                id: 49,
              },
            },
          ],
        },
      ]);

      const params = {
        project: "Contoso",
        team: "Fabrikam",
        backlogId: "Microsoft.FeatureCategory",
      };

      const result = await handler(params);

      expect(mockWorkApi.getBacklogLevelWorkItems).toHaveBeenCalledWith(
        { project: params.project, team: params.team },
        params.backlogId
      );

      expect(result.content[0].text).toBe(
        JSON.stringify([
          {
            workItems: [
              {
                rel: null,
                source: null,
                target: {
                  id: 50,
                },
              },
              {
                rel: null,
                source: null,
                target: {
                  id: 49,
                },
              },
            ],
          }],
          null,
          2
        )
      );
    });
  });

  describe("my_work_items tool", () => {
    it("should call getPredefinedQueryResults API with the correct parameters and return the expected result", async () => {
      configureWorkItemTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wit_my_work_items"
      );
      if (!call)
        throw new Error("wit_my_work_items tool not registered");
      const [, , , handler] = call;

      (mockWorkApi.getPredefinedQueryResults as jest.Mock).mockResolvedValue([
        {
          id: "assignedtome",
          name: "Assigned to me",
          url: "https://dev.azure.com/org/project/_apis/work/predefinedQueries/assignedtome",
          webUrl:"https://dev.azure.com/org/project/project/_workitems/assignedtome",
          hasMore: false,
          results: [
            {
              id: 115784,
              url: "https://dev.azure.com/org/_apis/wit/workItems/115784",
            },
            {
              id: 115794,
              url: "https://dev.azure.com/org/_apis/wit/workItems/115794",
            },
            {
              id: 115792,
              url: "https://dev.azure.com/org/_apis/wit/workItems/115792",
            },            
          ],
        },
      ]);

      const params = {
        project: "Contoso",
        type: "assignedtome",
        top: 10,
        includeCompleted: false,
      };

      const result = await handler(params);

      expect(mockWorkApi.getPredefinedQueryResults).toHaveBeenCalledWith(
        params.project,
        params.type,
        params.top,
        params.includeCompleted
      );
      
      expect(result.content[0].text).toBe(
        JSON.stringify([
           {
          id: "assignedtome",
          name: "Assigned to me",
          url: "https://dev.azure.com/org/project/_apis/work/predefinedQueries/assignedtome",
          webUrl:"https://dev.azure.com/org/project/project/_workitems/assignedtome",
          hasMore: false,
          results: [
            {
              id: 115784,
              url: "https://dev.azure.com/org/_apis/wit/workItems/115784",
            },
            {
              id: 115794,
              url: "https://dev.azure.com/org/_apis/wit/workItems/115794",
            },
            {
              id: 115792,
              url: "https://dev.azure.com/org/_apis/wit/workItems/115792",
            },            
          ],
        },],
          null,
          2
        )
      );
    });
  });

  describe("getWorkItemsBatch tool", () => {
    it("should call workItemApi.getWorkItemsBatch API with the correct parameters and return the expected result", async () => {
      configureWorkItemTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wit_get_work_items_batch_by_ids"
      );

      if (!call) throw new Error("wit_get_work_items_batch_by_ids tool not registered");
      const [, , , handler] = call;

      (mockWorkItemTrackingApi.getWorkItemsBatch as jest.Mock).mockResolvedValue([
        _mockWorkItems,
      ]);

      const params = {
        ids: [297, 299, 300],
        project: "Contoso",
      };

      const result = await handler(params);

      expect(mockWorkItemTrackingApi.getWorkItemsBatch).toHaveBeenCalledWith(
        { 
          ids: params.ids, 
          fields: ["System.Id", "System.WorkItemType", "System.Title", "System.State", "System.Parent", "System.Tags"] 
        },
        params.project
      );

      expect(result.content[0].text).toBe(
        JSON.stringify(
          [
           _mockWorkItems,
          ],
          null,
          2
        )
      );
    });
  });

  describe("get_work_item tool", () => {
    it("should call workItemApi.getWorkItem API with the correct parameters and return the expected result", async () => {
      configureWorkItemTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wit_get_work_item"
      );

      if (!call) throw new Error("wit_get_work_item tool not registered");
      const [, , , handler] = call;

      (mockWorkItemTrackingApi.getWorkItem as jest.Mock).mockResolvedValue([
        _mockWorkItem
      ]);

      const params = {
        id: 12,
        fields: undefined,
        asOf: undefined,
        expand: "none",
        project: "Contoso", 
      };

      const result = await handler(params);

      expect(mockWorkItemTrackingApi.getWorkItem).toHaveBeenCalledWith(
        params.id,
        params.fields,
        params.asOf,
        params.expand,
        params.project,     
      );

      expect(result.content[0].text).toBe(
        JSON.stringify(
          [
            _mockWorkItem,
          ],
          null,
          2
        )
      );
    });
  });

  describe("list_work_item_comments tool", () => {
    it("should call workItemApi.getComments API with the correct parameters and return the expected result", async () => {
      configureWorkItemTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wit_list_work_item_comments"
      );

      if (!call)throw new Error("wit_list_work_item_comments tool not registered");
      const [, , , handler] = call;

      (mockWorkItemTrackingApi.getComments as jest.Mock).mockResolvedValue([
        _mockWorkItemComments
      ]);

      const params = {
        project: "Contoso",
        workItemId: 299,
        top: 10,
      };

      const result = await handler(params);

      expect(mockWorkItemTrackingApi.getComments).toHaveBeenCalledWith(
        params.project,
        params.workItemId,
        params.top,      
      );
      
      expect(result.content[0].text).toBe(
        JSON.stringify(
          [
            _mockWorkItemComments,
          ],
          null,
          2
        )
      );
    });
  });

  describe("add_work_item_comment tool", () => {
    it("should call workItemApi.addComment API with the correct parameters and return the expected result", async () => {
      configureWorkItemTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wit_add_work_item_comment"
      );

      if (!call)throw new Error("wit_add_work_item_comment tool not registered");
      const [, , , handler] = call;

      (mockWorkItemTrackingApi.addComment as jest.Mock).mockResolvedValue([
        _mockWorkItemComment,
      ]);

      const params = {
        comment: "hello world!",
        project: "Contoso",
        workItemId: 299,       
      };

      const result = await handler(params);

      expect(mockWorkItemTrackingApi.addComment).toHaveBeenCalledWith(
        {text: params.comment},
        params.project,
        params.workItemId,
      );
      
      expect(result.content[0].text).toBe(
        JSON.stringify(
          [
            _mockWorkItemComment
          ],
          null,
          2
        )
      );
    });
  });

  describe("add_child_work_item tool", () => {
    it("should call workItemApi.add_child_work_item API with the correct parameters and return the expected result", async () => {
      configureWorkItemTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wit_add_child_work_item"
      );

      if (!call)throw new Error("wit_add_child_work_item tool not registered");
      const [, , , handler] = call;

      (mockWorkItemTrackingApi.createWorkItem as jest.Mock).mockResolvedValue([
        _mockWorkItem,
      ]);

      const params = {
        parentId: 299,
        project: "Contoso",
        workItemType: "Task",   
        title: "Sample task",
        description: "This is a sample task",
        areaPath: "Contoso\\Development",
        iterationPath: "Contoso\\Sprint 1",    
      };

        const document = [
          { 
            op: "add", 
            path: "/fields/System.Title", 
            value: params.title 
          },
          { 
            op: "add", 
            path: "/fields/System.Description", 
            value: params.description 
          },       
          {
            op: "add",
            path: "/relations/-",
            value: {
              rel: "System.LinkTypes.Hierarchy-Reverse",
              url: `undefined/${params.project}/_apis/wit/workItems/${params.parentId}`,
            },
          },
          {
            op: "add",
            path: "/fields/System.AreaPath",
            value: params.areaPath,
          },
          {
            op: "add",
            path: "/fields/System.IterationPath",
            value: params.iterationPath,
          }
        ];

      const result = await handler(params);

      expect(mockWorkItemTrackingApi.createWorkItem).toHaveBeenCalledWith(
        null,
        document,
        params.project,
        params.workItemType,
      );
      
      expect(result.content[0].text).toBe(
        JSON.stringify(
          [
            _mockWorkItem
          ],
          null,
          2
        )
      );
    });
  });

  describe("link_work_item_to_pull_request tool", () => {
    it("should call workItemApi.updateWorkItem API with the correct parameters and return the expected result", async () => {
      configureWorkItemTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wit_link_work_item_to_pull_request"
      );

      if (!call)throw new Error("wit_link_work_item_to_pull_request tool not registered");
      const [, , , handler] = call;

      (mockWorkItemTrackingApi.updateWorkItem as jest.Mock).mockResolvedValue([
          _mockWorkItem,
      ]);

      const params = {
        project: "Contoso",
        repositoryId: 12345,
        pullRequestId: 67890,
        workItemId: 131489,
      };

      const artifactPathValue = `${params.project}/${params.repositoryId}/${params.pullRequestId}`;
      const vstfsUrl = `vstfs:///Git/PullRequestId/${encodeURIComponent(artifactPathValue)}`;

      const document = [
        {
          op: "add",
          path: "/relations/-",
          value: {
            rel: "ArtifactLink",
            url: vstfsUrl,
            attributes: {
              name: "Pull Request",
            },
          },
        },
      ];

      const result = await handler(params);

      expect(mockWorkItemTrackingApi.updateWorkItem).toHaveBeenCalledWith(
        {},
        document,
        params.workItemId,
        params.project,       
      );
      
      expect(result.content[0].text).toBe(
        JSON.stringify(
          {
            workItemId: 131489,
            pullRequestId: 67890,
            success: true,
          },
          null,
          2
        )
      );
    });

    it("should handle errors from updateWorkItem and return a descriptive error", async () => {
      configureWorkItemTools(server, tokenProvider, connectionProvider);
      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wit_link_work_item_to_pull_request"
      );
      
      if (!call) throw new Error("wit_link_work_item_to_pull_request tool not registered");
      
      const [, , , handler] = call;
      (mockWorkItemTrackingApi.updateWorkItem as jest.Mock).mockRejectedValue(new Error("API failure"));
      
      const params = {
        project: "Contoso",
        repositoryId: 12345,
        pullRequestId: 67890,
        workItemId: 131489,
      };
      const result = await handler(params);

      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain("API failure");
    });

    it("should encode special characters in project and repositoryId for vstfsUrl", async () => {
      configureWorkItemTools(server, tokenProvider, connectionProvider);
      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wit_link_work_item_to_pull_request"
      );
      if (!call) throw new Error("wit_link_work_item_to_pull_request tool not registered");
      
      const [, , , handler] = call;
      (mockWorkItemTrackingApi.updateWorkItem as jest.Mock).mockResolvedValue([
        _mockWorkItem,
      ]);
      
      const params = {
        project: "Contoso Project",
        repositoryId: "repo/with/slash",
        pullRequestId: 67890,
        workItemId: 131489,
      };
      const artifactPathValue = `${params.project}/${params.repositoryId}/${params.pullRequestId}`;
      const vstfsUrl = `vstfs:///Git/PullRequestId/${encodeURIComponent(artifactPathValue)}`;
      const document = [
        {
          op: "add",
          path: "/relations/-",
          value: {
            rel: "ArtifactLink",
            url: vstfsUrl,
            attributes: {
              name: "Pull Request",
            },
          },
        },
      ];
      await handler(params);
      expect(mockWorkItemTrackingApi.updateWorkItem).toHaveBeenCalledWith(
        {},
        document,
        params.workItemId,
        params.project,
      );
    });
  });

  describe("get_work_items_for_iteration tool", () => {
    it("should call workApi.getIterationWorkItems API with the correct parameters and return the expected result", async () => {
      configureWorkItemTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wit_get_work_items_for_iteration"
      );

      if (!call)throw new Error("wit_get_work_items_for_iterationt tool not registered");
      const [, , , handler] = call;

      (mockWorkApi.getIterationWorkItems as jest.Mock).mockResolvedValue([        
          _mockWorkItemsForIteration,
      ]);

      const params = {
        project: "Contoso",
        team: "Fabrikam",
        iterationId: "6bfde89e-b22e-422e-814a-e8db432f5a58",
      };     

      const result = await handler(params);

      expect(mockWorkApi.getIterationWorkItems).toHaveBeenCalledWith(
        { 
          project: params.project, 
          team: params.team 
        },
        params.iterationId,       
      );
      
      expect(result.content[0].text).toBe(
        JSON.stringify(
          [
            _mockWorkItemsForIteration,
          ],
          null,
          2
        )
      );
    });
  });

  describe("update_work_item tool", () => {
    it("should call workItemApi.updateWorkItem API with the correct parameters and return the expected result", async () => {
      configureWorkItemTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wit_update_work_item"
      );

      if (!call)throw new Error("wit_update_work_item tool not registered");
      const [, , , handler] = call;

      (mockWorkItemTrackingApi.updateWorkItem as jest.Mock).mockResolvedValue([        
          _mockWorkItem,
      ]);

      const params = {
        id : 131489,
        updates: [
          { 
            op: "add",
            path: "/fields/System.Title",
            value: "Updated Sample Task"
          }
        ]
      };     

      const result = await handler(params);

      expect(mockWorkItemTrackingApi.updateWorkItem).toHaveBeenCalledWith(
        null,
        params.updates,
        params.id,      
      );
      
      expect(result.content[0].text).toBe(
        JSON.stringify(
          [
            _mockWorkItem
          ],
          null,
          2
        )
      );
    });
  });

  describe("get_work_item_type tool", () => {
    it("should call workItemApi.getWorkItemType API with the correct parameters and return the expected result", async () => {
      configureWorkItemTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wit_get_work_item_type"
      );

      if (!call)throw new Error("wit_get_work_item_type tool not registered");
      const [, , , handler] = call;

      (mockWorkItemTrackingApi.getWorkItemType as jest.Mock).mockResolvedValue([        
          _mockWorkItemType,
      ]);

      const params = {
       project: "Contoso",
        workItemType: "Bug",
      };     

      const result = await handler(params);

      expect(mockWorkItemTrackingApi.getWorkItemType).toHaveBeenCalledWith(
        params.project,
        params.workItemType,      
      );
      
      expect(result.content[0].text).toBe(
        JSON.stringify(
          [
            _mockWorkItemType
          ],
          null,
          2
        )
      );
    });
  });

  describe("create_work_item tool", () => {
    it("should call workItemApi.createWorkItem API with the correct parameters and return the expected result", async () => {
      configureWorkItemTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wit_create_work_item"
      );

      if (!call)throw new Error("wit_create_work_item tool not registered");
      const [, , , handler] = call;

      (mockWorkItemTrackingApi.createWorkItem as jest.Mock).mockResolvedValue([        
          _mockWorkItem,
      ]);

      const params = {
        project: "Contoso",
        workItemType: "Task",
        fields: [ 
          "System.Title", "Hello World!",
          "System.Description", "This is a sample task",
          "System.AreaPath", "Contoso\\Development",
        ]
      };     

      const document = Object.entries(params.fields).map(([key, value]) => ({
        op: "add",
        path: `/fields/${key}`,
        value,
      }));

      const result = await handler(params);

      expect(mockWorkItemTrackingApi.createWorkItem).toHaveBeenCalledWith(
        null,
        document,
        params.project,
        params.workItemType,     
      );
      
      expect(result.content[0].text).toBe(
        JSON.stringify(
          [
            _mockWorkItem
          ],
          null,
          2
        )
      );
    });
  });

  describe("get_query tool", () => {
    it("should call workItemApi.getQuery API with the correct parameters and return the expected result", async () => {
      configureWorkItemTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wit_get_query"
      );

      if (!call)throw new Error("wit_get_query tool not registered");
      const [, , , handler] = call;

      (mockWorkItemTrackingApi.getQuery as jest.Mock).mockResolvedValue([        
        _mockQuery,
      ]);

      const params = {
        project: "Contoso",
        query: "342f0f44-4069-46b1-a940-3d0468979ceb",
        expand: "none",
        depth: 1,
        includeDeleted: false,
        useIsoDateFormat: false,
      };     

      const result = await handler(params);

      expect(mockWorkItemTrackingApi.getQuery).toHaveBeenCalledWith(
        params.project,
        params.query,
        params.expand,
        params.depth,
        params.includeDeleted,
        params.useIsoDateFormat,      
      );
      
      expect(result.content[0].text).toBe(
        JSON.stringify(
          [
            _mockQuery,
          ],
          null,
          2
        )
      );
    });
  });

  describe("get_query_results_by_id tool", () => {
    it("should call workItemApi.getQueryById API with the correct parameters and return the expected result", async () => {
      configureWorkItemTools(server, tokenProvider, connectionProvider);

      const call = (server.tool as jest.Mock).mock.calls.find(
        ([toolName]) => toolName === "wit_get_query_results_by_id"
      );

      if (!call)throw new Error("wit_get_query_results_by_id tool not registered");
      const [, , , handler] = call;

      (mockWorkItemTrackingApi.queryById as jest.Mock).mockResolvedValue([        
        _mockQueryResults,
      ]);

      const params = {        
        id: "342f0f44-4069-46b1-a940-3d0468979ceb",
        project: "Contoso",
        team: "Fabrikam",
        timePrecision: false,
        top: 50,
      };     

      const result = await handler(params);

      expect(mockWorkItemTrackingApi.queryById).toHaveBeenCalledWith(
        params.id,
        { project: params.project, team: params.team },
        params.timePrecision,
        params.top     
      );
      
      expect(result.content[0].text).toBe(
        JSON.stringify(
          [
            _mockQueryResults,
          ],
          null,
          2
        )
      );
    });
  });

});


================================================
FILE: .azuredevops/pipelines/release.yml
================================================
trigger: none

schedules:
  - cron: "0 0 * * 1" # Runs every Monday at 00:00 UTC
    displayName: Release Latest Version
    branches:
      include:
        - main

jobs:
  - job: ReleaseLatest
    pool:
      vmImage: 'windows-latest'

    steps:
      - task: UseNode@1
        inputs:
          version: '20'
          checkLatest: false
          retryCountOnDownloadFails: 2

      - task: npmAuthenticate@0
        inputs:
          workingFile: .npmrc
        displayName: Authenticate with npm registry

      - task: Npm@1
        inputs:
          command: 'ci'
        displayName: Install clean dependencies

      - task: Npm@1
        inputs:
          command: 'custom'
          customCommand: 'run build'
        displayName: Build the project

      - task: EsrpCodeSigning@1
        displayName: 'Sign Binaries'
        inputs:
          ConnectedServiceName: 'ESRP Service'
          FolderPath: '$(Build.ArtifactStagingDirectory)'
          Pattern: |
            **/*.js
            **/*.ts
          signConfigType: 'inlineSignParams'
          inlineOperation: |
            [
              {
                "KeyCode": "CP-230012",
                "OperationCode": "SigntoolSign",
                "Parameters": {
                  "OpusName": "Azure DevOps MCP",
                  "OpusInfo": "https://github.com/microsoft/azure-devops-mcp",
                  "FileDigest": "/fd SHA256",
                  "PageHash": "/NPH",
                  "TimeStamp": "/tr http://timestamp.digicert.com /td SHA256"
                },
                "ToolName": "signtool.exe",
                "ToolVersion": "6.2.9304.0"
              },
              {
                "KeyCode": "CP-230012",
                "OperationCode": "SigntoolVerify",
                "Parameters": {},
                "ToolName": "signtool.exe",
                "ToolVersion": "6.2.9304.0"
              }
            ]
          SessionTimeout: '60'
          MaxConcurrency: '10'

      - task: Npm@1
        inputs:
          command: 'custom'
          customCommand: 'publish --access public --registry=https://registry.npmjs.org/'
        displayName: Publish package to public npmjs under @azure-devops org scope


================================================
FILE: .devcontainer/devcontainer.json
================================================
{
  "name": "Azure DevOps Local MCP Server",
  "image": "mcr.microsoft.com/devcontainers/typescript-node:20",
  "hostRequirements": {
    "cpus": 2,
    "memory": "8gb"
  },
  "features": {
    "ghcr.io/devcontainers/features/node:1": {
      "version": "20"
    },
    "ghcr.io/devcontainers/features/azure-cli:1": {}
  },
  "postCreateCommand": "rm -f .npmrc && npm install && npm install -g . ; az login --use-device-code",
  "customizations": {
    "codespaces": {
      "openFiles": [
        "CONTRIBUTING.md"
      ]
    },
    "vscode": {
      "extensions": [
        "ms-azuretools.vscode-docker",
        "GitHub.copilot",
        "dbaeumer.vscode-eslint",
        "esbenp.prettier-vscode",
        "ms-vscode.vscode-typescript-next"
      ]
    }
  },
  "remoteUser": "node"
}



================================================
FILE: .github/CODEOWNERS
================================================
# Define code owners for the codeowners file
.github/CODEOWNERS @danhellem @Novaes @aaudzei @skmanoj @kboom

# Define maintainers as code owners for the entire repository
* @danhellem @Novaes @aaudzei @skmanoj @kboom



================================================
FILE: .github/copilot-instructions.md
================================================
# Context
Act like an intelligent coding assistant, who helps test and author tools, prompts and resources for the Azure DevOps MCP server. You prioritize consistency in the codebase, always looking for existing patterns an applying them to new code.

If the user clearly intends to use a tool, do it.
If the user wants to author a new one, help him.

## Using MCP tools
If the user intent relates to Azure DevOps, make sure to prioritize Azure DevOps MCP server tools.

## Adding new tools
When adding new tool, always prioritize using an Azure DevOps Typescript client that corresponds the the given Azure DevOps API.
Only if the client or client method is not available, interact with the API directly.
The tools are located in the `src/tools.ts` file.

## Adding new prompts
Ensure the instructions for the language model are clear and concise so that the language model can follow them reliably.
The prompts are located in the `src/prompts.ts` file.



================================================
FILE: .github/dependabot.yml
================================================
version: 2
updates:
  - package-ecosystem: "npm"
    directory: "/"
    schedule:
      interval: "daily"
    open-pull-requests-limit: 2
    commit-message:
      prefix: "[dependencies]"


================================================
FILE: .github/PULL_REQUEST_TEMPLATE.md
================================================
_Replace_ by description of the work done

## GitHub issue number

## **Associated Risks**
_Replace_ by possible risks this pull request can bring you might have thought of

## ✅ **PR Checklist**

- [ ] **I have read the [contribution guidelines](https://github.com/microsoft/azure-devops-mcp/blob/main/CONTRIBUTING.md)**
- [ ] **I have read the [code of conduct guidelines](https://github.com/microsoft/azure-devops-mcp/blob/main/CODE_OF_CONDUCT.md)**
- [ ] Title of the pull request is clear and informative.
- [ ] 👌 Code hygiene
- [ ] 🔭 Telemetry added, updated, or N/A
- [ ] 📄 Documentation added, updated, or N/A
- [ ] 🛡️ Automated tests added, or N/A

## 🧪 **How did you test it?**
_Replace_ with use cases tested and models used


================================================
FILE: .github/acl/access.yml
================================================
# Documentation for ACL policy: https://aka.ms/gim/docs/policy/acl

name: Access control list
description: List of teams and their permission levels
resource: repository
where:
configuration:
  manageAccess:
  - member: Novaes
    role: Maintain
  - member: danhellem
    role: Maintain
  - member: aaudzei
    role: Maintain
  - member: skmanoj
    role: Write
  - member: KathanS
    role: Write
  - member: vinayakmsft
    role: Write



================================================
FILE: .github/ISSUE_TEMPLATE/JitAccess.yml
================================================
name: Temporary administrator access request
description: Request for temporary repository administrator access to this repository, a.k.a Just-in-Time (JIT) access.
title: "JIT Request"
labels: ["jit"]
assignees:
  - gimsvc_microsoft
  - 
body:
  - type: markdown
    attributes:
      value: |
        :closed_lock_with_key: Permanent repository administrator access is not allowed as per Microsoft security policy. You can use this form to request for temporary administrator access to this repository.
  - type: textarea
    id: justification
    attributes:
      label: Justification
      description: Describe the actions that you will perform with your temporary administrator access.
      placeholder: I need to create secrets.
    validations:
      required: true
  - type: dropdown
    id: duration
    attributes:
      label: Duration (hours)
      description: How long do you need access for? The duration you select is in hours.
      options:
        - 1
        - 2



================================================
FILE: .github/ISSUE_TEMPLATE/NewTool.md
================================================
---
name: Add new tool(s)
about: Use this template to leverage AI to add the tools you want
labels: enhancement, feature-request

---

Replace the content with your actual issue making sure to keep similar style so that GitHub Copilot can generate this change for you!
-------------------------------------------------------------------------------------------------------------------------------------
# Summary
Implement two new tools that integrate with Azure DevOps APIs to enable search capabilities.

# Tools
Develop the following tools with full parameter support, including optional ones:

## `search_wiki`: Search Azure DevOps Wikis for relevant content.
Endpoint: POST https://almsearch.dev.azure.com/{organization}/{project}/_apis/search/wikisearchresults?api-version=7.2-preview.1

## `search_code`: Search Azure DevOps Repos for relevant code results.
Endpoint: POST https://almsearch.dev.azure.com/{organization}/{project}/_apis/search/codesearchresults?api-version=7.2-preview.1

# Rules
1. Adhere strictly to existing project standards and coding conventions.
2. Ensure each tool exposes all API parameters (required and optional).
3. Use the official [Azure DevOps Node API](https://github.com/microsoft/azure-devops-node-api) to interact with the APIs.

# Special treat
If you follow the rules, you'll get candy!



================================================
FILE: .github/workflows/build.yml
================================================
name: Build MCP Server

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - "main"

jobs:
  build:
    name: Build the project
    runs-on: windows-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Remove .npmrc - uses standard registry for internal build check - non-release version
        run: |
          if (Test-Path .npmrc) {
            Remove-Item .npmrc
          }
        shell: pwsh

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 20

      - name: Clean install dependencies
        run: npm ci

      - name: Build the project
        run: npm run build

      - name: Run tests
        run: npm test

      - name: Validate server startup via npx
        shell: pwsh
        run: |
          $result = & npx mcp-server-azuredevops 2>&1
          if ($result -notmatch "Usage: mcp-server-azuredevops <organization_name>") {
            Write-Host "Expected usage message not found in output:"
            Write-Host $result
            exit 1
          }
          Write-Host "Validation passed."
          exit 0

  static-code-analysis:
    name: Static code analysis
    runs-on: windows-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 20

      - name: Clean install dependencies
        run: npm ci

      - name: Static code analysis
        run: npm run eslint

      - name: Verify package version is synced
        run: |
          git diff --exit-code ./src/version.ts
          if (!$?) {
            Write-Host "Version mismatch detected. Please run 'npm run build' to update version.ts and add changes to the commit."
            exit 1
          }
          git diff --exit-code ./package-lock.json
          if (!$?) {
            Write-Host "Please run 'npm install' to update package-lock.json and add changes to the commit."
            exit 1
          }



================================================
FILE: .github/workflows/codeql.yml
================================================
name: "CodeQL Advanced"

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  schedule:
    - cron: '42 15 * * 6'

jobs:
  analyze:
    name: Analyze (${{ matrix.language }})
    # Runner size impacts CodeQL analysis time. To learn more, please see:
    #   - https://gh.io/recommended-hardware-resources-for-running-codeql
    #   - https://gh.io/supported-runners-and-hardware-resources
    #   - https://gh.io/using-larger-runners (GitHub.com only)
    # Consider using larger runners or machines with greater resources for possible analysis time improvements.
    runs-on: windows-latest
    permissions:
      # required for all workflows
      security-events: write

      # required to fetch internal or private CodeQL packs
      packages: read

      # only required for workflows in private repositories
      actions: read
      contents: read

    strategy:
      fail-fast: false
      matrix:
        include:
        - language: actions
          build-mode: none
        - language: javascript-typescript
          build-mode: none
        # To learn more about changing the languages that are analyzed or customizing the build mode for your analysis,
        # see https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/customizing-your-advanced-setup-for-code-scanning.
        # If you are analyzing a compiled language, you can modify the 'build-mode' for that language to customize how
        # your codebase is analyzed, see https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/codeql-code-scanning-for-compiled-languages
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    # Add any setup steps before running the `github/codeql-action/init` action.
    # This includes steps like installing compilers or runtimes (`actions/setup-node`
    # or others). This is typically only required for manual builds.
    # - name: Setup runtime (example)
    #   uses: actions/setup-example@v1

    # Initializes the CodeQL tools for scanning.
    - name: Initialize CodeQL
      uses: github/codeql-action/init@v3
      with:
        languages: ${{ matrix.language }}
        build-mode: ${{ matrix.build-mode }}
        # If you wish to specify custom queries, you can do so here or in a config file.
        # By default, queries listed here will override any specified in a config file.
        # Prefix the list here with "+" to use these queries and those in the config file.

        # For more details on CodeQL's query packs, refer to: https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#using-queries-in-ql-packs
        # queries: security-extended,security-and-quality

    # If the analyze step fails for one of the languages you are analyzing with
    # "We were unable to automatically build your code", modify the matrix above
    # to set the build mode to "manual" for that language. Then modify this step
    # to build your code.
    # ℹ️ Command-line programs to run using the OS shell.
    # 📚 See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun
    - if: matrix.build-mode == 'manual'
      shell: bash
      run: |
        echo 'If you are using a "manual" build mode for one or more of the' \
          'languages you are analyzing, replace this with the commands to build' \
          'your code, for example:'
        echo '  make bootstrap'
        echo '  make release'
        exit 1

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v3
      with:
        category: "/language:${{matrix.language}}"



================================================
FILE: .github/workflows/dependency-review.yml
================================================
# Dependency Review Action
#
# This Action will scan dependency manifest files that change as part of a Pull Request,
# surfacing known-vulnerable versions of the packages declared or updated in the PR.
# Once installed, if the workflow run is marked as required, PRs introducing known-vulnerable
# packages will be blocked from merging.
#
# Source repository: https://github.com/actions/dependency-review-action
# Public documentation: https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-dependency-review#dependency-review-enforcement
name: 'Dependency review'
on:
  pull_request:
    branches: [ "main" ]

# If using a dependency submission action in this workflow this permission will need to be set to:
#
# permissions:
#   contents: write
#
# https://docs.github.com/en/enterprise-cloud@latest/code-security/supply-chain-security/understanding-your-software-supply-chain/using-the-dependency-submission-api
permissions:
  contents: read
  # Write permissions for pull-requests are required for using the `comment-summary-in-pr` option, comment out if you aren't using this option
  pull-requests: write

jobs:
  dependency-review:
    runs-on: windows-latest
    steps:
      - name: 'Checkout repository'
        uses: actions/checkout@v4
      - name: 'Dependency Review'
        uses: actions/dependency-review-action@v4
        # Commonly enabled options, see https://github.com/actions/dependency-review-action#configuration-options for all available options.
        with:
          comment-summary-in-pr: always
        #   fail-on-severity: moderate
        #   deny-licenses: GPL-1.0-or-later, LGPL-2.0-or-later
        #   retry-on-snapshot-warnings: true



================================================
FILE: .github/workflows/version-update.yml
================================================
name: Update Package Version

on:
  pull_request:
    types:
      - opened
      - edited
      - labeled
      - unlabeled

jobs:
  update-version:
    name: Update Package Version
    runs-on: windows-latest
    if: contains(github.event.pull_request.labels.*.name, 'minor') || contains(github.event.pull_request.labels.*.name, 'patch')

    steps:
      - name: Determine version type
        id: version_type
        run: |
          if ($env:GITHUB_EVENT_PULL_REQUEST_LABELS -contains "minor") {
            $env:VERSION_TYPE = "minor"
          } elseif ($env:GITHUB_EVENT_PULL_REQUEST_LABELS -contains "patch") {
            $env:VERSION_TYPE = "patch"
          } else {
            $env:VERSION_TYPE = ""
          }
        shell: pwsh

      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 20

      - name: Update package version and push tag
        if: env.VERSION_TYPE != ''
        run: |
          $newVersion = npm version $env:VERSION_TYPE
          git tag "v$newVersion"
          git push origin "v$newVersion"
        shell: pwsh

      - name: Push changes
        if: env.VERSION_TYPE != ''
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git push origin HEAD:main
        shell: pwsh


